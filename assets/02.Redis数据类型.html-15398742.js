import{_ as i}from"./plugin-vue_export-helper-c27b6911.js";import{r as p,o,c as l,a as n,b as s,d as e,e as t}from"./app-103fb7a1.js";const c={},d=t(`<h1 id="redis-数据类型" tabindex="-1"><a class="header-anchor" href="#redis-数据类型" aria-hidden="true">#</a> Redis 数据类型</h1><blockquote><p>关键词：<code>String</code>、<code>Hash</code>、<code>List</code>、<code>Set</code>、<code>Zset</code>、<code>BitMap</code>、<code>HyperLogLog</code>、<code>Geo</code>、<code>Stream</code></p></blockquote><p>Redis 提供了多种数据类型，每种数据类型有丰富的命令支持。</p><p>Redis 支持的基本数据类型：STRING、HASH、LIST、SET、ZSET</p><p>Redis 支持的高级数据类型：BitMap、HyperLogLog、GEO、Stream</p><p>使用 Redis ，不仅要了解其数据类型的特性，还需要根据业务场景，灵活的、高效的使用其数据类型来建模。</p><h2 id="string" tabindex="-1"><a class="header-anchor" href="#string" aria-hidden="true">#</a> String</h2><h3 id="string-简介" tabindex="-1"><a class="header-anchor" href="#string-简介" aria-hidden="true">#</a> String 简介</h3><p>String 类型是键值对结构。</p><p>String 类型是<strong>二进制安全</strong>的。二进制安全是指，String 类型不仅可以保存文本数据，还可以保存任意格式的二进制数据，如：图片、音频、视频、压缩文件等。</p><p>默认情况下，String 类型的值最大可为 <strong>512 MB</strong>。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-string.png" width="400"></div><h3 id="string-实现" tabindex="-1"><a class="header-anchor" href="#string-实现" aria-hidden="true">#</a> String 实现</h3><p>String 类型的底层的数据结构实现主要是 int 和 SDS（简单动态字符串）。</p><p>SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：</p><ul><li><strong>SDS 不仅可以保存文本数据，还可以保存二进制数据</strong>。因为 <code>SDS</code> 使用 <code>len</code> 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 <code>buf[]</code> 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。</li><li><strong>SDS 获取字符串长度的时间复杂度是 O(1)</strong>。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 <code>len</code> 属性记录了字符串长度，所以复杂度为 <code>O(1)</code>。</li><li><strong>Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出</strong>。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。</li></ul><p><strong>字符串对象的编码可以是 <code>int</code> 、 <code>raw</code> 或者 <code>embstr</code></strong> 。</p><p>字符串对象保存各类型值的编码方式：</p><table><thead><tr><th style="text-align:left;">值</th><th style="text-align:left;">编码</th></tr></thead><tbody><tr><td style="text-align:left;">可以用 <code>long</code> 类型保存的整数。</td><td style="text-align:left;"><code>int</code></td></tr><tr><td style="text-align:left;">可以用 <code>long double</code> 类型保存的浮点数。</td><td style="text-align:left;"><code>embstr</code> 或者 <code>raw</code></td></tr><tr><td style="text-align:left;">字符串值， 或者因为长度太大而没办法用 <code>long</code> 类型表示的整数， 又或者因为长度太大而没办法用 <code>long double</code> 类型表示的浮点数。</td><td style="text-align:left;"><code>embstr</code> 或者 <code>raw</code></td></tr></tbody></table><p>如果一个字符串对象保存的是整数值， 并且这个整数值可以用 <code>long</code> 类型来表示， 那么字符串对象会将整数值保存在字符串对象结构的 <code>ptr</code> 属性里面（将 <code>void*</code> 转换成 <code>long</code> ）， 并将字符串对象的编码设置为 <code>int</code> 。</p><p>【示例】</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SET number <span class="token number">10086</span>
OK

<span class="token operator">&gt;</span> OBJECT ENCODING number
<span class="token string">&quot;int&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度大于 <code>39</code> 字节， 那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值， 并将对象的编码设置为 <code>raw</code> 。</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">&gt;</span> SET story <span class="token string">&quot;Long, long, long ago there lived a king ...&quot;</span>
OK

<span class="token operator">&gt;</span> STRLEN <span class="token function">story</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">43</span>

<span class="token operator">&gt;</span> OBJECT ENCODING story
<span class="token string">&quot;raw&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果字符串对象保存的是一个字符串值， 并且这个字符串值的长度小于等于 <code>39</code> 字节， 那么字符串对象将使用 <code>embstr</code> 编码的方式来保存这个字符串值。<code>embstr</code> 编码是专门用于保存短字符串的一种优化编码方式。</p><p>【示例】</p><div class="language-c line-numbers-mode" data-ext="c"><pre class="language-c"><code><span class="token operator">&gt;</span> SET msg <span class="token string">&quot;hello&quot;</span>
OK

<span class="token operator">&gt;</span> OBJECT ENCODING msg
<span class="token string">&quot;embstr&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string-命令" tabindex="-1"><a class="header-anchor" href="#string-命令" aria-hidden="true">#</a> String 命令</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td><code>SET</code></td><td>存储一个字符串值</td></tr><tr><td><code>SETNX</code></td><td>仅当键不存在时，才存储字符串值</td></tr><tr><td><code>GET</code></td><td>获取指定 key 的值</td></tr><tr><td><code>MGET</code></td><td>获取一个或多个指定 key 的值</td></tr><tr><td><code>INCRBY</code></td><td>将 key 中储存的数字加上指定的增量值</td></tr><tr><td><code>DECRBY</code></td><td>将 key 中储存的数字减去指定的减量值</td></tr></tbody></table>`,29),r={href:"https://redis.io/commands#string",target:"_blank",rel:"noopener noreferrer"},u=t(`<p>【示例】SET、GET、DEL 操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将 key(name) 的 value 保存为 dunwu</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> name dunwu
OK
<span class="token comment"># 获取 key(name) 的 value</span>
<span class="token operator">&gt;</span> get name
<span class="token string">&quot;dunwu&quot;</span>
<span class="token comment"># 将 key(name) 的 value 保存为 unknown（覆盖原 value）</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> name unknown
OK
<span class="token operator">&gt;</span> get name
<span class="token string">&quot;unknown&quot;</span>
<span class="token comment"># 检查 key(name) 是否存在</span>
<span class="token operator">&gt;</span> exists name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># 删除 key(name)</span>
<span class="token operator">&gt;</span> del name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token operator">&gt;</span> exists name
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token operator">&gt;</span> get name
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【示例】SETNX 操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 检查 key(lock) 是否存在</span>
<span class="token operator">&gt;</span> exists lock
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token comment"># 将 key(lock) 的 value 保存为 1，保存成功</span>
<span class="token operator">&gt;</span> setnx lock <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># 将 key(lock) 的 value 保存为 2，由于 key 已存在，保存失败</span>
<span class="token operator">&gt;</span> setnx lock <span class="token number">2</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token comment"># 获取 key(lock) 的 value</span>
<span class="token operator">&gt;</span> get lock
<span class="token string">&quot;1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【示例】MSET、MGET 操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 批量设置 one、two、three 这 3 个 key</span>
<span class="token operator">&gt;</span> mset one <span class="token number">1</span> tow <span class="token number">2</span> three <span class="token number">3</span>
OK
<span class="token comment"># 批量获取 one、two、three 3 个 key 的 value</span>
<span class="token operator">&gt;</span> mget one tow three
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;2&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;3&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【示例】INCR、DECR、INCRBY、DECRBY 操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将 key(counter) 的 value 保存为 0</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> counter <span class="token number">0</span>
OK
<span class="token comment"># 将 key(counter) 的 value 加 1</span>
<span class="token operator">&gt;</span> incr counter
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># 将 key(counter) 的 value 加 9</span>
<span class="token operator">&gt;</span> incrby counter <span class="token number">9</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">10</span>
<span class="token comment"># 将 key(counter) 的 value 减 1</span>
<span class="token operator">&gt;</span> decr counter
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">9</span>
<span class="token comment"># 将 key(counter) 的 value 减 9</span>
<span class="token operator">&gt;</span> decrby counter <span class="token number">9</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="string-应用" tabindex="-1"><a class="header-anchor" href="#string-应用" aria-hidden="true">#</a> String 应用</h3><p><strong>适用场景：缓存、计数器、共享 Session</strong></p><h4 id="缓存对象" tabindex="-1"><a class="header-anchor" href="#缓存对象" aria-hidden="true">#</a> 缓存对象</h4><p>使用 String 来缓存对象有两种方式：</p><p>（1）缓存对象的 JSON 值</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> user:1 <span class="token punctuation">{</span><span class="token string">&quot;name&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;dunwu&quot;</span>,<span class="token string">&quot;sex&quot;</span><span class="token builtin class-name">:</span><span class="token string">&quot;man&quot;</span><span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>（2）将 key 分离为 user:ID:属性的形式，采用 MSET 存储，用 MGET 获取各属性值</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> mset user:1:name dunwu user:1:sex <span class="token function">man</span>
OK
<span class="token operator">&gt;</span> mget user:1:name user:1:sex
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;dunwu&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;man&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="计数器" tabindex="-1"><a class="header-anchor" href="#计数器" aria-hidden="true">#</a> 计数器</h4><p>【需求场景】</p><p>统计网站某内容的点击量、收藏量、点赞数等等。</p><p>【解决方案】</p><blockquote><p>使用 Redis 的 String 类型存储一个计数器。</p></blockquote><p>维护计数器的常见操作如下：</p><ul><li>增加统计值 - 使用 <code>INCR</code>、<code>DECR</code> 命令</li><li>减少统计值 - 使用 <code>INCRBY</code>、<code>DECRBY</code> 操作</li></ul><p>【示例代码】</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 初始化 ID 为 1024 的博文访问量为 0</span>
<span class="token operator">&gt;</span> <span class="token builtin class-name">set</span> blog:view:1024 <span class="token number">0</span>
OK
<span class="token comment"># ID 为 1024 的博文访问量加 1</span>
<span class="token operator">&gt;</span> incr blog:view:1024
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># ID 为 1024 的博文访问量加 1</span>
<span class="token operator">&gt;</span> incr blog:view:1024
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token comment"># 查看 ID 为 1024 的博文访问量</span>
<span class="token operator">&gt;</span> get blog:view:1024
<span class="token string">&quot;2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="分布式锁" tabindex="-1"><a class="header-anchor" href="#分布式锁" aria-hidden="true">#</a> 分布式锁</h4><p>（1）申请锁</p><p>SET 命令有个 NX 参数可以实现「key 不存在才插入」，可以用它来实现分布式锁：</p><ul><li>如果 key 不存在，则显示插入成功，可以用来表示加锁成功；</li><li>如果 key 存在，则会显示插入失败，可以用来表示加锁失败。</li></ul><p>一般而言，还会对分布式锁加上过期时间，分布式锁的命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SET key value NX PX <span class="token number">30000</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>key - 就是分布式锁的关键字；</li><li>value - 是客户端生成的唯一的标识；</li><li>NX - 表示只有 <code>key</code> 不存在的时候才会设置成功。（如果此时 redis 中存在这个 key，那么设置失败，返回 <code>nil</code>）</li><li>PX 30000 - 表示：30s 后，key 会被删除（这意味着锁被释放了）。设置过期时间，是为了防止出现各种意外，导致锁始终无法释放的情况。</li></ul><p>（2）释放锁</p><p>释放锁就是删除 key ，但是一般可以用 <code>lua</code> 脚本删除，判断 value 一样才删除，这是为了保证释放锁操作和申请所操作是同一个客户端。由于涉及两个操作，为了保证原子性，可以使用 lua 脚本来实现，因为 Redis 执行 Lua 脚本时，是以原子性方式执行的。</p><div class="language-Lua line-numbers-mode" data-ext="Lua"><pre class="language-Lua"><code>-- 删除锁的时候，找到 key 对应的 value，跟自己传过去的 value 做比较，如果是一样的才删除。
if redis.call(&quot;get&quot;,KEYS[1]) == ARGV[1] then
    return redis.call(&quot;del&quot;,KEYS[1])
else
    return 0
end
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="共享-session-信息" tabindex="-1"><a class="header-anchor" href="#共享-session-信息" aria-hidden="true">#</a> 共享 Session 信息</h4><p>在分布式场景下，一个用户的 Session 如果只存储在一个服务器上，那么当负载均衡器把用户的下一个请求转发到另一个服务器上，该服务器没有用户的 Session，就可能导致用户需要重新进行登录等操作。</p><p>分布式 Session 的几种实现策略：</p><ol><li>粘性 session</li><li>应用服务器间的 session 复制共享</li><li>基于缓存的 session 共享 ✅</li></ol><p>基于缓存的 session 共享实现</p><blockquote><p><strong>使用一个单独的存储服务器存储 Session 数据</strong>，可以存在 MySQL 数据库上，也可以存在 Redis 或者 Memcached 这种内存型数据库。</p><p>缺点：需要去实现存取 Session 的代码。</p></blockquote><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/design/architecture/MultiNode-SpringSession.jpg"></div>`,42),m=t('<h3 id="hash-简介" tabindex="-1"><a class="header-anchor" href="#hash-简介" aria-hidden="true">#</a> Hash 简介</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-hash.png" width="400"></div><p>Hash 是一个键值对（key - value）集合，其中 value 的形式如： <code>value=[{field1，value1}，...{fieldN，valueN}]</code>。Hash 特别适合用于存储对象。</p><h3 id="hash-实现" tabindex="-1"><a class="header-anchor" href="#hash-实现" aria-hidden="true">#</a> Hash 实现</h3><p>哈希对象的编码可以是 <code>ziplist</code> 或者 <code>hashtable</code> 。</p><p><code>ziplist</code> 编码的哈希对象使用压缩列表作为底层实现，每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾。</p><p><code>hashtable</code> 编码的哈希对象使用字典作为底层实现， 哈希对象中的每个键值对都使用一个字典键值对来保存。</p><p>当哈希对象同时满足以下两个条件时， 使用 <code>ziplist</code> 编码；否则，使用 <code>hashtable</code> 编码。</p><ol><li>哈希对象保存的所有键值对的键和值的字符串长度都小于 <code>64</code> 字节；</li><li>哈希对象保存的键值对数量小于 <code>512</code> 个；</li></ol><blockquote><p>注意：这两个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>hash-max-ziplist-value</code> 选项和 <code>hash-max-ziplist-entries</code> 选项的说明。</p></blockquote><h3 id="hash-命令" tabindex="-1"><a class="header-anchor" href="#hash-命令" aria-hidden="true">#</a> Hash 命令</h3><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>HSET</code></td><td>将指定字段的值设为 value</td></tr><tr><td><code>HGET</code></td><td>获取指定字段的值</td></tr><tr><td><code>HGETALL</code></td><td>获取所有键值对</td></tr><tr><td><code>HMSET</code></td><td>设置多个键值对</td></tr><tr><td><code>HMGET</code></td><td>获取所有指定字段的值</td></tr><tr><td><code>HDEL</code></td><td>删除指定字段</td></tr><tr><td><code>HINCRBY</code></td><td>为指定字段的整数值加上增量</td></tr><tr><td><code>HKEYS</code></td><td>获取所有字段</td></tr></tbody></table>',12),v={href:"https://redis.io/commands#hash",target:"_blank",rel:"noopener noreferrer"},b=t(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表key的键值</span>
HSET key field value
<span class="token comment"># 获取哈希表key对应的field键值</span>
HGET key field

<span class="token comment"># 在一个哈希表key中存储多个键值对</span>
HMSET key field value <span class="token punctuation">[</span>field value<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 批量获取哈希表key中多个field键值</span>
HMGET key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 删除哈希表key中的field键值</span>
HDEL key field <span class="token punctuation">[</span>field <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回哈希表key中field的数量</span>
HLEN key
<span class="token comment"># 返回哈希表key中所有的键值</span>
HGETALL key

<span class="token comment"># 为哈希表key中field键的值加上增量n</span>
HINCRBY key field n
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hash-应用" tabindex="-1"><a class="header-anchor" href="#hash-应用" aria-hidden="true">#</a> Hash 应用</h3><blockquote><p><strong>Hash 类型适用于存储结构化数据</strong>。</p></blockquote><h4 id="缓存对象-1" tabindex="-1"><a class="header-anchor" href="#缓存对象-1" aria-hidden="true">#</a> 缓存对象</h4><p>Hash 类型的（key，field，value）的结构与对象的（对象 id，属性，值）的结构相似，也可以用来存储对象。</p><p>我们以用户信息为例，它在关系型数据库中的结构是这样的：</p><p>我们可以使用如下命令，将用户对象的信息存储到 Hash 类型：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储一个哈希表uid:1的键值</span>
<span class="token operator">&gt;</span> HMSET uid:1 name Tom age <span class="token number">15</span>
<span class="token number">2</span>
<span class="token comment"># 存储一个哈希表uid:2的键值</span>
<span class="token operator">&gt;</span> HMSET uid:2 name Jerry age <span class="token number">13</span>
<span class="token number">2</span>
<span class="token comment"># 获取哈希表用户id为1中所有的键值</span>
<span class="token operator">&gt;</span> HGETALL uid:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;15&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Redis Hash 存储其结构如下图：</p><p>在介绍 String 类型的应用场景时有所介绍，String + Json 也是存储对象的一种方式，那么存储对象时，到底用 String + json 还是用 Hash 呢？</p><p>一般对象用 String + Json 存储，对象中某些频繁变化的属性可以考虑抽出来用 Hash 类型存储。</p><h4 id="购物车" tabindex="-1"><a class="header-anchor" href="#购物车" aria-hidden="true">#</a> 购物车</h4><p>【需求场景】</p><p>用户浏览电商平台，添加商品到购物车，并支持查看购物车。需要考虑未登录的情况。</p><p>【解决方案】</p><blockquote><p>可以使用 HASH 类型来实现购物车功能。</p><p>以用户 session 为 key，存储了商品 ID 和商品数量的映射。其中，商品 id 为 field，商品数量为 value。</p><p>为什么不使用用户 ID？</p><p>因为很多场景下需要支持用户在免登陆的情况下使用购物车的，因为未登录，所以无法知道用户的用户 ID，这种情况下使用用户 session 更合适。并且由于绑定的是 session，可以在清空 session 时，顺便清空购物车缓存，更加方便。</p></blockquote><p>维护购物车的常见操作如下：</p><ul><li>添加商品 - <code>HSET cart:{session} {商品id} 1</code></li><li>添加数量 - <code>HINCRBY cart:{session} {商品id} 1</code></li><li>商品总数 - <code>HLEN cart:{session}</code></li><li>删除商品 - <code>HDEL cart:{session} {商品id}</code></li><li>获取购物车所有商品 - <code>HGETALL cart:{session}</code></li></ul><p>当前仅仅是将商品 ID 存储到了 Redis 中，在回显商品具体信息的时候，还需要拿着商品 id 查询一次数据库，获取完整的商品的信息。</p><h2 id="list" tabindex="-1"><a class="header-anchor" href="#list" aria-hidden="true">#</a> List</h2><p>Redis 中的 List 类型就是有序列表。</p><h3 id="list-简介" tabindex="-1"><a class="header-anchor" href="#list-简介" aria-hidden="true">#</a> List 简介</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-list.png" width="400"></div><p>List 列表是简单的字符串列表，<strong>按照插入顺序排序</strong>，可以从头部或尾部向 List 列表添加元素。</p><p>列表的最大长度为 <code>2^32 - 1</code>，也即每个列表支持超过 <code>40 亿</code>个元素。</p><h3 id="list-实现" tabindex="-1"><a class="header-anchor" href="#list-实现" aria-hidden="true">#</a> List 实现</h3><p>列表对象的编码可以是 <code>ziplist</code> 或者 <code>linkedlist</code> 。</p><p><code>ziplist</code> 编码的列表对象使用压缩列表作为底层实现， 每个压缩列表节点（entry）保存了一个列表元素。</p><figure><img src="http://redisbook.com/_images/graphviz-a8d31075b4c0537f4eb6d84aaba1df928c67c953.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>inkedlist</code> 编码的列表对象使用双链表作为底层实现。</p><figure><img src="http://redisbook.com/_images/graphviz-84c0d231f30c740a431407c7aaf3851b96399590.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当列表对象可以同时满足以下两个条件时， 列表对象使用 <code>ziplist</code> 编码；否则，使用 <code>linkedlist</code> 编码</p><ol><li>列表对象保存的所有字符串元素的长度都小于 <code>64</code> 字节；</li><li>列表对象保存的元素数量小于 <code>512</code> 个；</li></ol><blockquote><p>注意</p><p>以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 <code>list-max-ziplist-value</code> 选项和 <code>list-max-ziplist-entries</code> 选项的说明。</p></blockquote><h3 id="list-命令" tabindex="-1"><a class="header-anchor" href="#list-命令" aria-hidden="true">#</a> List 命令</h3><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>LPUSH</code></td><td>将给定值推入列表的右端。</td></tr><tr><td><code>RPUSH</code></td><td>将给定值推入列表的右端。</td></tr><tr><td><code>LPOP</code></td><td>从列表的左端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>RPOP</code></td><td>从列表的右端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>LRANGE</code></td><td>获取列表在给定范围上的所有值。</td></tr><tr><td><code>LINDEX</code></td><td>获取列表在给定位置上的单个元素。</td></tr><tr><td><code>LREM</code></td><td>从列表的左端弹出一个值，并返回被弹出的值。</td></tr><tr><td><code>LTRIM</code></td><td>只保留指定区间内的元素，删除其他元素。</td></tr></tbody></table>`,36),k={href:"https://redis.io/commands#list",target:"_blank",rel:"noopener noreferrer"},g=t(`<div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 将一个或多个值value插入到key列表的表头(最左边)，最后的值在最前面</span>
LPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将一个或多个值value插入到key列表的表尾(最右边)</span>
RPUSH key value <span class="token punctuation">[</span>value <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 移除并返回key列表的头元素</span>
LPOP key
<span class="token comment"># 移除并返回key列表的尾元素</span>
RPOP key

<span class="token comment"># 返回列表key中指定区间内的元素，区间以偏移量start和stop指定，从0开始</span>
LRANGE key start stop

<span class="token comment"># 从key列表表头弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BLPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
<span class="token comment"># 从key列表表尾弹出一个元素，没有就阻塞timeout秒，如果timeout=0则一直阻塞</span>
BRPOP key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span> <span class="token function">timeout</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="list-应用" tabindex="-1"><a class="header-anchor" href="#list-应用" aria-hidden="true">#</a> List 应用</h3><h4 id="消息队列" tabindex="-1"><a class="header-anchor" href="#消息队列" aria-hidden="true">#</a> 消息队列</h4><p>消息队列在存取消息时，必须要满足三个需求，分别是<strong>消息保序、处理重复的消息和保证消息可靠性</strong>。</p><p>Redis 的 List 和 Stream 两种数据类型，就可以满足消息队列的这三个需求。我们先来了解下基于 List 的消息队列实现方法，后面在介绍 Stream 数据类型时候，在详细说说 Stream。</p><p><em>1、如何满足消息保序需求？</em></p><p>List 本身就是按先进先出的顺序对数据进行存取的，所以，如果使用 List 作为消息队列保存消息的话，就已经能满足消息保序的需求了。</p><p>List 可以使用 LPUSH + RPOP（或者反过来，RPUSH+LPOP）命令实现消息队列。</p><ul><li><p>生产者使用 <code>LPUSH key value[value...]</code> 将消息插入到队列的头部，如果 key 不存在则会创建一个空的队列再插入消息。</p></li><li><p>消费者使用 <code>RPOP key</code> 依次读取队列的消息，先进先出。</p></li></ul><p>不过，在消费者读取数据时，有一个潜在的性能风险点。</p><p>在生产者往 List 中写入数据时，List 并不会主动地通知消费者有新消息写入，如果消费者想要及时处理消息，就需要在程序中不停地调用 <code>RPOP</code> 命令（比如使用一个 while(1) 循环）。如果有新消息写入，RPOP 命令就会返回结果，否则，RPOP 命令返回空值，再继续循环。</p><p>所以，即使没有新消息写入 List，消费者也要不停地调用 RPOP 命令，这就会导致消费者程序的 CPU 一直消耗在执行 RPOP 命令上，带来不必要的性能损失。</p><p>为了解决这个问题，Redis 提供了 BRPOP 命令。<strong>BRPOP 命令也称为阻塞式读取，客户端在没有读到队列数据时，自动阻塞，直到有新的数据写入队列，再开始读取新数据</strong>。和消费者程序自己不停地调用 RPOP 命令相比，这种方式能节省 CPU 开销。</p><p><em>2、如何处理重复的消息？</em></p><p>消费者要实现重复消息的判断，需要 2 个方面的要求：</p><ul><li>每个消息都有一个全局的 ID。</li><li>消费者要记录已经处理过的消息的 ID。当收到一条消息后，消费者程序就可以对比收到的消息 ID 和记录的已处理过的消息 ID，来判断当前收到的消息有没有经过处理。如果已经处理过，那么，消费者程序就不再进行处理了。</li></ul><p>但是 <strong>List 并不会为每个消息生成 ID 号，所以我们需要自行为每个消息生成一个全局唯一 ID</strong>，生成之后，我们在用 LPUSH 命令把消息插入 List 时，需要在消息中包含这个全局唯一 ID。</p><p>例如，我们执行以下命令，就把一条全局 ID 为 111000102、库存量为 99 的消息插入了消息队列：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> LPUSH mq <span class="token string">&quot;111000102:stock:99&quot;</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p><em>3、如何保证消息可靠性？</em></p><p>当消费者程序从 List 中读取一条消息后，List 就不会再留存这条消息了。所以，如果消费者程序在处理消息的过程出现了故障或宕机，就会导致消息没有处理完成，那么，消费者程序再次启动后，就没法再次从 List 中读取消息了。</p><p>为了留存消息，List 类型提供了 <code>BRPOPLPUSH</code> 命令，这个命令的<strong>作用是让消费者程序从一个 List 中读取消息，同时，Redis 会把这个消息再插入到另一个 List（可以叫作备份 List）留存</strong>。</p><p>这样一来，如果消费者程序读了消息但没能正常处理，等它重启后，就可以从备份 List 中重新读取消息并进行处理了。</p><p>好了，到这里可以知道基于 List 类型的消息队列，满足消息队列的三大需求（消息保序、处理重复的消息和保证消息可靠性）。</p><ul><li>消息保序：使用 LPUSH + RPOP；</li><li>阻塞读取：使用 BRPOP；</li><li>重复消息处理：生产者自行实现全局唯一 ID；</li><li>消息的可靠性：使用 BRPOPLPUSH</li></ul><blockquote><p>List 作为消息队列有什么缺陷？</p></blockquote><p><strong>List 不支持多个消费者消费同一条消息</strong>，因为一旦消费者拉取一条消息后，这条消息就从 List 中删除了，无法被其它消费者再次消费。</p><p>要实现一条消息可以被多个消费者消费，那么就要将多个消费者组成一个消费组，使得多个消费者可以消费同一条消息，但是 <strong>List 类型并不支持消费组的实现</strong>。</p><p>这就要说起 Redis 从 5.0 版本开始提供的 Stream 数据类型了，Stream 同样能够满足消息队列的三大需求，而且它还支持「消费组」形式的消息读取。</p><h4 id="输入自动补全" tabindex="-1"><a class="header-anchor" href="#输入自动补全" aria-hidden="true">#</a> 输入自动补全</h4><p>【需求场景】</p><p>根据用户输入，自动补全信息，如：联系人、商品名等。</p><ul><li>典型场景一 - 社交网站后台记录用户最近联系过的 100 个好友，当用户查找好友时，根据输入的关键字自动补全姓名。</li><li>典型场景二 - 电商网站后台记录用户最近浏览过的 10 件商品，当用户查找商品是，根据输入的关键字自动补全商品名称。</li></ul><p>【解决方案】</p><blockquote><p>使用 Redis 的 List 类型存储一个最近信息列表，然后在需要自动补全信息时展示相应数量的数据。</p></blockquote><p>维护最近信息列表的常见操作如下：</p><ul><li>如果指定信息经存在于最近信息列表里，那么从列表里移除。使用 <code>LREM</code> 命令。</li><li>将指定信息添加到最近信息列表的头部。使用 <code>LPUSH</code> 命令。</li><li>添加操作完成后，如果最近信息列表中的数量超过上限 N，进行裁剪操作。使用 <code>LTRIM</code> 命令。</li></ul><h2 id="set" tabindex="-1"><a class="header-anchor" href="#set" aria-hidden="true">#</a> Set</h2><p>Redis 中的 Set 类型就是无序且去重的集合。</p><h3 id="set-简介" tabindex="-1"><a class="header-anchor" href="#set-简介" aria-hidden="true">#</a> Set 简介</h3><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-set.png" width="400"></div><p>Set 类型是一个无序并唯一的键值集合，它的存储顺序不会按照插入的先后顺序进行存储。</p><p>一个集合最多可以存储 <code>2^32-1</code> 个元素。概念和数学中个的集合基本类似，可以交集，并集，差集等等，所以 Set 类型除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p><p>Set 类型和 List 类型的区别如下：</p><ul><li>List 可以存储重复元素，Set 只能存储非重复元素；</li><li>List 是按照元素的先后顺序存储元素的，而 Set 则是无序方式存储元素的。</li></ul><h3 id="set-实现" tabindex="-1"><a class="header-anchor" href="#set-实现" aria-hidden="true">#</a> Set 实现</h3><p>Set 类型的底层数据结构是由<strong>哈希表或整数集合</strong>实现的：</p><ul><li>如果集合中的元素都是整数且元素个数小于 <code>512</code> （默认值，<code>set-maxintset-entries</code>配置）个，Redis 会使用<strong>整数集合</strong>作为 Set 类型的底层数据结构；</li><li>如果集合中的元素不满足上面条件，则 Redis 使用<strong>哈希表</strong>作为 Set 类型的底层数据结构。</li></ul><h3 id="set-命令" tabindex="-1"><a class="header-anchor" href="#set-命令" aria-hidden="true">#</a> Set 命令</h3><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>SADD</code></td><td>将给定元素添加到集合。</td></tr><tr><td><code>SMEMBERS</code></td><td>返回集合包含的所有元素。</td></tr><tr><td><code>SISMEMBER</code></td><td>检查给定元素是否存在于集合中。</td></tr><tr><td><code>SREM</code></td><td>如果给定的元素存在于集合中，那么移除这个元素。</td></tr></tbody></table>`,50),h={href:"https://redis.io/commands#set",target:"_blank",rel:"noopener noreferrer"},S=t(`<p>Set 常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往集合key中存入元素，元素存在则忽略，若key不存在则新建</span>
SADD key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 从集合key中删除元素</span>
SREM key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 获取集合key中所有元素</span>
SMEMBERS key
<span class="token comment"># 获取集合key中的元素个数</span>
SCARD key

<span class="token comment"># 判断member元素是否存在于集合key中</span>
SISMEMBER key member

<span class="token comment"># 从集合key中随机选出count个元素，元素不从key中删除</span>
SRANDMEMBER key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
<span class="token comment"># 从集合key中随机选出count个元素，元素从key中删除</span>
SPOP key <span class="token punctuation">[</span>count<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Set 运算操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 交集运算</span>
SINTER key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将交集结果存入新集合destination中</span>
SINTERSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 并集运算</span>
SUNION key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将并集结果存入新集合destination中</span>
SUNIONSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 差集运算</span>
SDIFF key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 将差集结果存入新集合destination中</span>
SDIFFSTORE destination key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="set-应用" tabindex="-1"><a class="header-anchor" href="#set-应用" aria-hidden="true">#</a> Set 应用</h3><p>集合的主要几个特性，无序、不可重复、支持并交差等操作。</p><p>因此 Set 类型比较适合用来数据去重和保障数据的唯一性，还可以用来统计多个集合的交集、错集和并集等，当我们存储的数据是无序并且需要去重的情况下，比较适合使用集合类型进行存储。</p><p>但是要提醒你一下，这里有一个潜在的风险。<strong>Set 的差集、并集和交集的计算复杂度较高，在数据量较大的情况下，如果直接执行这些计算，会导致 Redis 实例阻塞</strong>。</p><p>在主从集群中，为了避免主库因为 Set 做聚合计算（交集、差集、并集）时导致主库被阻塞，我们可以选择一个从库完成聚合统计，或者把数据返回给客户端，由客户端来完成聚合统计。</p><h4 id="点赞" tabindex="-1"><a class="header-anchor" href="#点赞" aria-hidden="true">#</a> 点赞</h4><p>Set 类型可以保证一个用户只能点一个赞，这里举例子一个场景，key 是文章 id，value 是用户 id。</p><p><code>uid:1</code> 、<code>uid:2</code>、<code>uid:3</code> 三个用户分别对 article:1 文章点赞了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># uid:1 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># uid:2 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># uid:3 用户对文章 article:1 点赞</span>
<span class="token operator">&gt;</span> SADD article:1 uid:3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>uid:1</code> 取消了对 article:1 文章点赞。</p><div class="language-plain line-numbers-mode" data-ext="plain"><pre class="language-plain"><code>&gt; SREM article:1 uid:1
(integer) 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 article:1 文章所有点赞用户 :</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SMEMBERS article:1
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;uid:3&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;uid:2&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 article:1 文章的点赞用户数量：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SCARD article:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>判断用户 <code>uid:1</code> 是否对文章 article:1 点赞了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SISMEMBER article:1 uid:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>  <span class="token comment"># 返回0说明没点赞，返回1则说明点赞了</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="共同关注" tabindex="-1"><a class="header-anchor" href="#共同关注" aria-hidden="true">#</a> 共同关注</h4><p>Set 类型支持交集运算，所以可以用来计算共同关注的好友、公众号等。</p><p>key 可以是用户 id，value 则是已关注的公众号的 id。</p><p><code>uid:1</code> 用户关注公众号 id 为 5、6、7、8、9，<code>uid:2</code> 用户关注公众号 id 为 7、8、9、10、11。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># uid:1 用户关注公众号 id 为 5、6、7、8、9</span>
<span class="token operator">&gt;</span> SADD uid:1 <span class="token number">5</span> <span class="token number">6</span> <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token comment"># uid:2  用户关注公众号 id 为 7、8、9、10、11</span>
<span class="token operator">&gt;</span> SADD uid:2 <span class="token number">7</span> <span class="token number">8</span> <span class="token number">9</span> <span class="token number">10</span> <span class="token number">11</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>uid:1</code> 和 <code>uid:2</code> 共同关注的公众号：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 获取共同关注</span>
<span class="token operator">&gt;</span> SINTER uid:1 uid:2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;7&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;8&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;9&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>给 <code>uid:2</code> 推荐 <code>uid:1</code> 关注的公众号：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SDIFF uid:1 uid:2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;5&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;6&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>验证某个公众号是否同时被 <code>uid:1</code> 或 <code>uid:2</code> 关注：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> SISMEMBER uid:1 <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span> <span class="token comment"># 返回1，说明关注了</span>
<span class="token operator">&gt;</span> SISMEMBER uid:2 <span class="token number">5</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span> <span class="token comment"># 返回0，说明没关注</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="抽奖活动" tabindex="-1"><a class="header-anchor" href="#抽奖活动" aria-hidden="true">#</a> 抽奖活动</h4><p>存储某活动中中奖的用户名，Set 类型因为有去重功能，可以保证同一个用户不会中奖两次。</p><p>key 为抽奖活动名，value 为员工名称，把所有员工名称放入抽奖箱：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span>SADD lucky Tom Jerry John Sean Marry Lindy Sary Mark
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>如果允许重复中奖，可以使用 SRANDMEMBER 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 抽取 1 个一等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
<span class="token comment"># 抽取 2 个二等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Mark&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>
<span class="token comment"># 抽取 3 个三等奖：</span>
<span class="token operator">&gt;</span> SRANDMEMBER lucky <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Sary&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果不允许重复中奖，可以使用 SPOP 命令。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 抽取一等奖1个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">1</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Sary&quot;</span>
<span class="token comment"># 抽取二等奖2个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">2</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Jerry&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Mark&quot;</span>
<span class="token comment"># 抽取三等奖3个</span>
<span class="token operator">&gt;</span> SPOP lucky <span class="token number">3</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;John&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Sean&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Lindy&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="zset" tabindex="-1"><a class="header-anchor" href="#zset" aria-hidden="true">#</a> Zset</h2><p>Redis 中的 Zset 类型就是有序且去重的集合。</p><h3 id="zset-简介" tabindex="-1"><a class="header-anchor" href="#zset-简介" aria-hidden="true">#</a> Zset 简介</h3><p>Zset 类型（有序集合类型）相比于 Set 类型多了一个排序属性 score（分值），对于有序集合 ZSet 来说，每个存储元素相当于有两个值组成的，一个是有序结合的元素值，一个是排序值。</p><p>有序集合保留了集合不能有重复成员的特性（分值可以重复），但不同的是，有序集合中的元素可以排序。</p><div align="center"><img src="https://raw.githubusercontent.com/dunwu/images/dev/cs/database/redis/redis-datatype-zset.png" width="400"></div><h3 id="zset-实现" tabindex="-1"><a class="header-anchor" href="#zset-实现" aria-hidden="true">#</a> Zset 实现</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h3 id="zset-命令" tabindex="-1"><a class="header-anchor" href="#zset-命令" aria-hidden="true">#</a> Zset 命令</h3><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>ZADD</code></td><td>将一个带有给定分值的成员添加到有序集合里面</td></tr><tr><td><code>ZRANGE</code></td><td>顺序排序，并返回指定排名区间的成员</td></tr><tr><td>ZREVRANGE</td><td>反序排序，并返回指定排名区间的成员</td></tr><tr><td><code>ZRANGEBYSCORE</code></td><td>顺序排序，并返回指定排名区间的成员及其分值</td></tr><tr><td>ZREVRANGEBYSCORE</td><td>反序排序，并返回指定排名区间的成员及其分值</td></tr><tr><td><code>ZREM</code></td><td>移除指定的成员</td></tr><tr><td><code>ZSCORE</code></td><td>返回指定成员的分值</td></tr><tr><td><code>ZCARD</code></td><td>返回所有成员数</td></tr></tbody></table>`,52),q={href:"https://redis.io/commands#sorted_set",target:"_blank",rel:"noopener noreferrer"},y=t(`<p>Zset 常用操作：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 往有序集合key中加入带分值元素</span>
ZADD key score member <span class="token punctuation">[</span><span class="token punctuation">[</span>score member<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 往有序集合key中删除元素</span>
ZREM key member <span class="token punctuation">[</span>member<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 返回有序集合key中元素member的分值</span>
ZSCORE key member
<span class="token comment"># 返回有序集合key中元素个数</span>
ZCARD key

<span class="token comment"># 为有序集合key中元素member的分值加上increment</span>
ZINCRBY key increment member

<span class="token comment"># 正序获取有序集合key从start下标到stop下标的元素</span>
ZRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>
<span class="token comment"># 倒序获取有序集合key从start下标到stop下标的元素</span>
ZREVRANGE key start stop <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span>

<span class="token comment"># 返回有序集合中指定分数区间内的成员，分数由低到高排序。</span>
ZRANGEBYSCORE key min max <span class="token punctuation">[</span>WITHSCORES<span class="token punctuation">]</span> <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>

<span class="token comment"># 返回指定成员区间内的成员，按字典正序排列, 分数必须相同。</span>
ZRANGEBYLEX key min max <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
<span class="token comment"># 返回指定成员区间内的成员，按字典倒序排列, 分数必须相同</span>
ZREVRANGEBYLEX key max min <span class="token punctuation">[</span>LIMIT offset count<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Zset 运算操作（相比于 Set 类型，ZSet 类型没有支持差集运算）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 并集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZUNIONSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
<span class="token comment"># 交集计算(相同元素分值相加)，numberkeys一共多少个key，WEIGHTS每个key对应的分值乘积</span>
ZINTERSTORE destkey numberkeys key <span class="token punctuation">[</span>key<span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="zset-应用" tabindex="-1"><a class="header-anchor" href="#zset-应用" aria-hidden="true">#</a> Zset 应用</h3><p>Zset 类型（Sorted Set，有序集合）可以根据元素的权重来排序，我们可以自己来决定每个元素的权重值。比如说，我们可以根据元素插入 Sorted Set 的时间确定权重值，先插入的元素权重小，后插入的元素权重大。</p><p>在面对需要展示最新列表、排行榜等场景时，如果数据更新频繁或者需要分页显示，可以优先考虑使用 Sorted Set。</p><h4 id="排行榜" tabindex="-1"><a class="header-anchor" href="#排行榜" aria-hidden="true">#</a> 排行榜</h4><p>【需求场景】</p><p>各种排行榜，如：内容平台（视频、歌曲、文章）的播放量/收藏量/评分排行榜；电商网站的销售排行榜；</p><p>【解决方案】</p><p>有序集合比较典型的使用场景就是排行榜。例如学生成绩的排名榜、游戏积分排行榜、视频播放排名、电商系统中商品的销量排名等。</p><p>我们以博文点赞排名为例，小林发表了五篇博文，分别获得赞为 200、40、100、50、150。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># arcticle:1 文章获得了200个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">200</span> arcticle:1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># arcticle:2 文章获得了40个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">40</span> arcticle:2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># arcticle:3 文章获得了100个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">100</span> arcticle:3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># arcticle:4 文章获得了50个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">50</span> arcticle:4
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token comment"># arcticle:5 文章获得了150个赞</span>
<span class="token operator">&gt;</span> ZADD user:xiaolin:ranking <span class="token number">150</span> arcticle:5
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>文章 arcticle:4 新增一个赞，可以使用 ZINCRBY 命令（为有序集合 key 中元素 member 的分值加上 increment）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZINCRBY user:xiaolin:ranking <span class="token number">1</span> arcticle:4
<span class="token string">&quot;51&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>查看某篇文章的赞数，可以使用 ZSCORE 命令（返回有序集合 key 中元素个数）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZSCORE user:xiaolin:ranking arcticle:4
<span class="token string">&quot;50&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取小林文章赞数最多的 3 篇文章，可以使用 ZREVRANGE 命令（倒序获取有序集合 key 从 start 下标到 stop 下标的元素）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># WITHSCORES 表示把 score 也显示出来</span>
<span class="token operator">&gt;</span> ZREVRANGE user:xiaolin:ranking <span class="token number">0</span> <span class="token number">2</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:1&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:3&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取小林 100 赞到 200 赞的文章，可以使用 ZRANGEBYSCORE 命令（返回有序集合中指定分数区间内的成员，分数由低到高排序）：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYSCORE user:xiaolin:ranking <span class="token number">100</span> <span class="token number">200</span> WITHSCORES
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:3&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;100&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:5&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;150&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;arcticle:1&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;200&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="前缀排序" tabindex="-1"><a class="header-anchor" href="#前缀排序" aria-hidden="true">#</a> 前缀排序</h4><p>使用有序集合的 <code>ZRANGEBYLEX</code> 或 <code>ZREVRANGEBYLEX</code> 可以帮助我们实现电话号码或姓名的排序，我们以 <code>ZRANGEBYLEX</code> （返回指定成员区间内的成员，按 key 正序排列，分数必须相同）为例。</p><p><strong>注意：不要在分数不一致的 SortSet 集合中去使用 ZRANGEBYLEX 和 ZREVRANGEBYLEX 指令，因为获取的结果会不准确。</strong></p><p><em>1、电话排序</em></p><p>我们可以将电话号码存储到 SortSet 中，然后根据需要来获取号段：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZADD phone <span class="token number">0</span> <span class="token number">13100111100</span> <span class="token number">0</span> <span class="token number">13110114300</span> <span class="token number">0</span> <span class="token number">13132110901</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token operator">&gt;</span> ZADD phone <span class="token number">0</span> <span class="token number">13200111100</span> <span class="token number">0</span> <span class="token number">13210414300</span> <span class="token number">0</span> <span class="token number">13252110901</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token operator">&gt;</span> ZADD phone <span class="token number">0</span> <span class="token number">13300111100</span> <span class="token number">0</span> <span class="token number">13310414300</span> <span class="token number">0</span> <span class="token number">13352110901</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取所有号码：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX phone - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;13100111100&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;13110114300&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;13132110901&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;13200111100&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;13210414300&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;13252110901&quot;</span>
<span class="token number">7</span><span class="token punctuation">)</span> <span class="token string">&quot;13300111100&quot;</span>
<span class="token number">8</span><span class="token punctuation">)</span> <span class="token string">&quot;13310414300&quot;</span>
<span class="token number">9</span><span class="token punctuation">)</span> <span class="token string">&quot;13352110901&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 132 号段的号码：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX phone <span class="token punctuation">[</span><span class="token number">132</span> <span class="token punctuation">(</span><span class="token number">133</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;13200111100&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;13210414300&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;13252110901&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取 132、133 号段的号码：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX phone <span class="token punctuation">[</span><span class="token number">132</span> <span class="token punctuation">(</span><span class="token number">134</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;13200111100&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;13210414300&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;13252110901&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;13300111100&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;13310414300&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;13352110901&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><em>2、姓名排序</em></p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> zadd names <span class="token number">0</span> Toumas <span class="token number">0</span> Jake <span class="token number">0</span> Bluetuo <span class="token number">0</span> Gaodeng <span class="token number">0</span> Aimini <span class="token number">0</span> Aidehua
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>获取所有人的名字：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX names - +
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Aidehua&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Aimini&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Bluetuo&quot;</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token string">&quot;Gaodeng&quot;</span>
<span class="token number">5</span><span class="token punctuation">)</span> <span class="token string">&quot;Jake&quot;</span>
<span class="token number">6</span><span class="token punctuation">)</span> <span class="token string">&quot;Toumas&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取名字中大写字母 A 开头的所有人：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX names <span class="token punctuation">[</span>A <span class="token punctuation">(</span>B
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Aidehua&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Aimini&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>获取名字中大写字母 C 到 Z 的所有人：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> ZRANGEBYLEX names <span class="token punctuation">[</span>C <span class="token punctuation">[</span>Z
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;Gaodeng&quot;</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Jake&quot;</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;Toumas&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="bitmap" tabindex="-1"><a class="header-anchor" href="#bitmap" aria-hidden="true">#</a> BitMap</h2><h3 id="bitmap-简介" tabindex="-1"><a class="header-anchor" href="#bitmap-简介" aria-hidden="true">#</a> BitMap 简介</h3><p>Bitmap，<strong>即位图，是一串连续的二进制数组（0 和 1）</strong>，可以通过偏移量（offset）定位元素。由于 bit 是计算机中最小的单位，使用它进行储存将<strong>非常节省空间</strong>，特别适合一些数据量大且使用<strong>二值统计的场景</strong>。例如在一个系统中，不同的用户使用单调递增的用户 ID 表示。40 亿（$$2^{32}$$ = $$4<em>1024</em>1024*1024$$ ≈ 40 亿）用户只需要 512M 内存就能记住某种状态，例如用户是否已登录。</p><h3 id="bitmap-实现" tabindex="-1"><a class="header-anchor" href="#bitmap-实现" aria-hidden="true">#</a> BitMap 实现</h3><p>实际上，<strong>BitMap 不是真实的数据结构，而是针对 String 实现的一组位操作</strong>。</p><p>由于 STRING 是二进制安全的，并且其最大长度是 512 MB，所以 BitMap 能最大设置 $$2^{32}$$ 个不同的 bit。</p><h3 id="bitmap-命令" tabindex="-1"><a class="header-anchor" href="#bitmap-命令" aria-hidden="true">#</a> BitMap 命令</h3><table><thead><tr><th>命令</th><th>行为</th></tr></thead><tbody><tr><td><code>SETBIT</code></td><td>对 key 所储存的字符串值，设置或清除指定偏移量上的位(bit)</td></tr><tr><td><code>GETBIT</code></td><td>对 key 所储存的字符串值，获取指定偏移量上的位(bit)</td></tr><tr><td><code>BITOP</code></td><td>对一个或多个字符串执行位运算</td></tr></tbody></table><p>【示例】SETBIT、GETBIT 操作</p><p>假设有 1000 个传感器，标记为 0-999。现在，想要快速确定某传感器是否在一小时内对服务器执行了 ping 操作。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 传感器 123 在 2024 年 1 月 1 日 00:00 内对服务器执行 ping 操作</span>
<span class="token operator">&gt;</span> SETBIT pings:2024-01-01-00:00 <span class="token number">123</span> <span class="token number">1</span>
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span>
<span class="token comment"># 传感器 123 是否在 2024 年 1 月 1 日 00:00 内对服务器执行 ping 操作</span>
<span class="token operator">&gt;</span> GETBIT pings:2024-01-01-00:00 <span class="token number">123</span>
<span class="token number">1</span>
What about sensor <span class="token number">456</span>?
<span class="token operator">&gt;</span> GETBIT pings:2024-01-01-00:00 <span class="token number">456</span>
<span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【示例】BITOP 操作</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># BitMap间的运算</span>
<span class="token comment"># operations 位移操作符，枚举值</span>
  AND 与运算 <span class="token operator">&amp;</span>
  OR 或运算 <span class="token operator">|</span>
  XOR 异或 ^
  NOT 取反 ~
<span class="token comment"># result 计算的结果，会存储在该key中</span>
<span class="token comment"># key1 … keyn 参与运算的key，可以有多个，空格分割，not运算只能一个key</span>
<span class="token comment"># 当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 0。返回值是保存到 destkey 的字符串的长度（以字节byte为单位），和输入 key 中最长的字符串长度相等。</span>
BITOP <span class="token punctuation">[</span>operations<span class="token punctuation">]</span> <span class="token punctuation">[</span>result<span class="token punctuation">]</span> <span class="token punctuation">[</span>key1<span class="token punctuation">]</span> <span class="token punctuation">[</span>keyn…<span class="token punctuation">]</span>

<span class="token comment"># 返回指定key中第一次出现指定value(0/1)的位置</span>
BITPOS <span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token punctuation">[</span>value<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="bitmap-应用" tabindex="-1"><a class="header-anchor" href="#bitmap-应用" aria-hidden="true">#</a> BitMap 应用</h3><p>Bitmap 类型非常适合二值状态统计的场景，这里的二值状态就是指集合元素的取值就只有 0 和 1 两种，在记录海量数据时，Bitmap 能够有效地节省内存空间。</p><h4 id="签到统计" tabindex="-1"><a class="header-anchor" href="#签到统计" aria-hidden="true">#</a> 签到统计</h4><p>在签到打卡的场景中，我们只用记录签到（1）或未签到（0），所以它就是非常典型的二值状态。</p><p>签到统计时，每个用户一天的签到用 1 个 bit 位就能表示，一个月（假设是 31 天）的签到情况用 31 个 bit 位就可以，而一年的签到也只需要用 365 个 bit 位，根本不用太复杂的集合类型。</p><p>假设我们要统计 ID 100 的用户在 2022 年 6 月份的签到情况，就可以按照下面的步骤进行操作。</p><p>第一步，执行下面的命令，记录该用户 6 月 3 号已签到。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT uid:sign:100:202206 <span class="token number">2</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，检查该用户 6 月 3 日是否签到。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GETBIT uid:sign:100:202206 <span class="token number">2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，统计该用户在 6 月份的签到次数。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>BITCOUNT uid:sign:100:202206
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这样，我们就知道该用户在 6 月份的签到情况了。</p><blockquote><p>如何统计这个月首次打卡时间呢？</p></blockquote><p>Redis 提供了 <code>BITPOS key bitValue [start] [end]</code>指令，返回数据表示 Bitmap 中第一个值为 <code>bitValue</code> 的 offset 位置。</p><p>在默认情况下，命令将检测整个位图，用户可以通过可选的 <code>start</code> 参数和 <code>end</code> 参数指定要检测的范围。所以我们可以通过执行这条命令来获取 userID = 100 在 2022 年 6 月份<strong>首次打卡</strong>日期：</p><div class="language-apache line-numbers-mode" data-ext="apache"><pre class="language-apache"><code>BITPOS uid:sign:100:202206 1
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>需要注意的是，因为 offset 从 0 开始的，所以我们需要将返回的 value + 1。</p><h4 id="判断用户是否登录" tabindex="-1"><a class="header-anchor" href="#判断用户是否登录" aria-hidden="true">#</a> 判断用户是否登录</h4><p>Bitmap 提供了 <code>GETBIT、SETBIT</code> 操作，通过一个偏移值 offset 对 bit 数组的 offset 位置的 bit 位进行读写操作，需要注意的是 offset 从 0 开始。</p><p>只需要一个 key = login_status 表示存储用户登陆状态集合数据，将用户 ID 作为 offset，在线就设置为 1，下线设置 0。通过 <code>GETBIT</code>判断对应的用户是否在线。50000 万 用户只需要 6 MB 的空间。</p><p>假如我们要判断 ID = 10086 的用户的登陆情况：</p><p>第一步，执行以下指令，表示用户已登录。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第二步，检查该用户是否登陆，返回值 1 表示已登录。</p><div class="language-apache line-numbers-mode" data-ext="apache"><pre class="language-apache"><code>GETBIT login_status 10086
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>第三步，登出，将 offset 对应的 value 设置成 0。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>SETBIT login_status <span class="token number">10086</span> <span class="token number">0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="连续签到用户总数" tabindex="-1"><a class="header-anchor" href="#连续签到用户总数" aria-hidden="true">#</a> 连续签到用户总数</h4><p>如何统计出这连续 7 天连续打卡用户总数呢？</p><p>我们把每天的日期作为 Bitmap 的 key，userId 作为 offset，若是打卡则将 offset 位置的 bit 设置成 1。</p><p>key 对应的集合的每个 bit 位的数据则是一个用户在该日期的打卡记录。</p><p>一共有 7 个这样的 Bitmap，如果我们能对这 7 个 Bitmap 的对应的 bit 位做 『与』运算。同样的 UserID offset 都是一样的，当一个 userID 在 7 个 Bitmap 对应对应的 offset 位置的 bit = 1 就说明该用户 7 天连续打卡。</p><p>结果保存到一个新 Bitmap 中，我们再通过 <code>BITCOUNT</code> 统计 bit = 1 的个数便得到了连续打卡 7 天的用户总数了。</p><p>Redis 提供了 <code>BITOP operation destkey key [key ...]</code>这个指令用于对一个或者多个 key 的 Bitmap 进行位元操作。</p><ul><li><code>operation</code> 可以是 <code>and</code>、<code>OR</code>、<code>NOT</code>、<code>XOR</code>。当 BITOP 处理不同长度的字符串时，较短的那个字符串所缺少的部分会被看作 <code>0</code> 。空的 <code>key</code> 也被看作是包含 <code>0</code> 的字符串序列。</li></ul><p>假设要统计 3 天连续打卡的用户数，则是将三个 bitmap 进行 AND 操作，并将结果保存到 destmap 中，接着对 destmap 执行 BITCOUNT 统计，如下命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 与操作</span>
BITOP AND destmap bitmap:01 bitmap:02 bitmap:03
<span class="token comment"># 统计 bit 位 =  1 的个数</span>
BITCOUNT destmap
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>即使一天产生一个亿的数据，Bitmap 占用的内存也不大，大约占 12 MB 的内存（10^8/8/1024/1024），7 天的 Bitmap 的内存开销约为 84 MB。同时我们最好给 Bitmap 设置过期时间，让 Redis 删除过期的打卡数据，节省内存。</p><h2 id="hyperloglog" tabindex="-1"><a class="header-anchor" href="#hyperloglog" aria-hidden="true">#</a> HyperLogLog</h2><h3 id="hyperloglog-简介" tabindex="-1"><a class="header-anchor" href="#hyperloglog-简介" aria-hidden="true">#</a> HyperLogLog 简介</h3><p>Redis HyperLogLog 是 Redis 2.8.9 版本新增的数据类型，是一种用于「统计基数」的数据集合类型，基数统计就是指统计一个集合中不重复的元素个数。但要注意，HyperLogLog 是统计规则是基于概率完成的，不是非常准确，标准误算率是 0.81%。</p><p>所以，简单来说 HyperLogLog <strong>提供不精确的去重计数</strong>。</p><p>HyperLogLog 的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的内存空间总是固定的、并且是很小的。</p><p>在 Redis 里面，<strong>每个 HyperLogLog 键只需要花费 12 KB 内存，就可以计算接近 <code>2^64</code> 个不同元素的基数</strong>，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>这什么概念？举个例子给大家对比一下。</p><p>用 Java 语言来说，一般 long 类型占用 8 字节，而 1 字节有 8 位，即：1 byte = 8 bit，即 long 数据类型最大可以表示的数是：<code>2^63-1</code>。对应上面的<code>2^64</code>个数，假设此时有<code>2^63-1</code>这么多个数，从 <code>0 ~ 2^63-1</code>，按照<code>long</code>以及<code>1k = 1024 字节</code>的规则来计算内存总数，就是：<code>((2^63-1) * 8/1024)K</code>，这是很庞大的一个数，存储空间远远超过<code>12K</code>，而 <code>HyperLogLog</code> 却可以用 <code>12K</code> 就能统计完。</p><h3 id="hyperloglog-实现" tabindex="-1"><a class="header-anchor" href="#hyperloglog-实现" aria-hidden="true">#</a> HyperLogLog 实现</h3>`,103),E={href:"https://en.wikipedia.org/wiki/HyperLogLog",target:"_blank",rel:"noopener noreferrer"},R=t(`<h3 id="hyperloglog-命令" tabindex="-1"><a class="header-anchor" href="#hyperloglog-命令" aria-hidden="true">#</a> HyperLogLog 命令</h3><p>HyperLogLog 命令很少，就三个。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 添加指定元素到 HyperLogLog 中</span>
PFADD key element <span class="token punctuation">[</span>element <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回给定 HyperLogLog 的基数估算值。</span>
PFCOUNT key <span class="token punctuation">[</span>key <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 将多个 HyperLogLog 合并为一个 HyperLogLog</span>
PFMERGE destkey sourcekey <span class="token punctuation">[</span>sourcekey <span class="token punctuation">..</span>.<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="hyperloglog-应用" tabindex="-1"><a class="header-anchor" href="#hyperloglog-应用" aria-hidden="true">#</a> HyperLogLog 应用</h3><h4 id="百万级网页-uv-计数" tabindex="-1"><a class="header-anchor" href="#百万级网页-uv-计数" aria-hidden="true">#</a> 百万级网页 UV 计数</h4><p>Redis HyperLogLog 优势在于只需要花费 12 KB 内存，就可以计算接近 2^64 个元素的基数，和元素越多就越耗费内存的 Set 和 Hash 类型相比，HyperLogLog 就非常节省空间。</p><p>所以，非常适合统计百万级以上的网页 UV 的场景。</p><p>在统计 UV 时，你可以用 PFADD 命令（用于向 HyperLogLog 中添加新元素）把访问页面的每个用户都添加到 HyperLogLog 中。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PFADD page1:uv user1 user2 user3 user4 user5
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>接下来，就可以用 PFCOUNT 命令直接获得 page1 的 UV 值了，这个命令的作用就是返回 HyperLogLog 的统计结果。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>PFCOUNT page1:uv
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>不过，有一点需要你注意一下，HyperLogLog 的统计规则是基于概率完成的，所以它给出的统计结果是有一定误差的，标准误算率是 0.81%。</p><p>这也就意味着，你使用 HyperLogLog 统计的 UV 是 100 万，但实际的 UV 可能是 101 万。虽然误差率不算大，但是，如果你需要精确统计结果的话，最好还是继续用 Set 或 Hash 类型。</p><h2 id="geo" tabindex="-1"><a class="header-anchor" href="#geo" aria-hidden="true">#</a> GEO</h2><h3 id="geo-简介" tabindex="-1"><a class="header-anchor" href="#geo-简介" aria-hidden="true">#</a> GEO 简介</h3><p>Redis GEO 是 Redis 3.2 版本新增的数据类型，主要用于存储地理位置信息，并对存储的信息进行操作。</p><p>在日常生活中，我们越来越依赖搜索“附近的餐馆”、在打车软件上叫车，这些都离不开基于位置信息服务（Location-Based Service，LBS）的应用。LBS 应用访问的数据是和人或物关联的一组经纬度信息，而且要能查询相邻的经纬度范围，GEO 就非常适合应用在 LBS 服务的场景中。</p><h3 id="geo-实现" tabindex="-1"><a class="header-anchor" href="#geo-实现" aria-hidden="true">#</a> GEO 实现</h3><p>GEO 本身并没有设计新的底层数据结构，而是直接使用了 Zset 类型。</p><p>GEO 类型使用 GeoHash 编码方法实现了经纬度到 Sorted Set 中元素权重分数的转换，这其中的两个关键机制就是「对二维地图做区间划分」和「对区间进行编码」。一组经纬度落在某个区间后，就用区间的编码值来表示，并把编码值作为 Sorted Set 元素的权重分数。</p><p>这样一来，我们就可以把经纬度保存到 Sorted Set 中，利用 Sorted Set 提供的“按权重进行有序范围查找”的特性，实现 LBS 服务中频繁使用的“搜索附近”的需求。</p><h3 id="geo-命令" tabindex="-1"><a class="header-anchor" href="#geo-命令" aria-hidden="true">#</a> GEO 命令</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 存储指定的地理空间位置，可以将一个或多个经度(longitude)、纬度(latitude)、位置名称(member)添加到指定的 key 中。</span>
GEOADD key longitude latitude member <span class="token punctuation">[</span>longitude latitude member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 从给定的 key 里返回所有指定名称(member)的位置（经度和纬度），不存在的返回 nil。</span>
GEOPOS key member <span class="token punctuation">[</span>member <span class="token punctuation">..</span>.<span class="token punctuation">]</span>

<span class="token comment"># 返回两个给定位置之间的距离。</span>
GEODIST key member1 member2 <span class="token punctuation">[</span>m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi<span class="token punctuation">]</span>

<span class="token comment"># 根据用户给定的经纬度坐标来获取指定范围内的地理位置集合。</span>
GEORADIUS key longitude latitude radius m<span class="token operator">|</span>km<span class="token operator">|</span>ft<span class="token operator">|</span>mi <span class="token punctuation">[</span>WITHCOORD<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHDIST<span class="token punctuation">]</span> <span class="token punctuation">[</span>WITHHASH<span class="token punctuation">]</span> <span class="token punctuation">[</span>COUNT count<span class="token punctuation">]</span> <span class="token punctuation">[</span>ASC<span class="token operator">|</span>DESC<span class="token punctuation">]</span> <span class="token punctuation">[</span>STORE key<span class="token punctuation">]</span> <span class="token punctuation">[</span>STOREDIST key<span class="token punctuation">]</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="geo-应用" tabindex="-1"><a class="header-anchor" href="#geo-应用" aria-hidden="true">#</a> GEO 应用</h3><h4 id="滴滴叫车" tabindex="-1"><a class="header-anchor" href="#滴滴叫车" aria-hidden="true">#</a> 滴滴叫车</h4><p>这里以滴滴叫车的场景为例，介绍下具体如何使用 GEO 命令：GEOADD 和 GEORADIUS 这两个命令。</p><p>假设车辆 ID 是 33，经纬度位置是（116.034579，39.030452），我们可以用一个 GEO 集合保存所有车辆的经纬度，集合 key 是 cars:locations。</p><p>执行下面的这个命令，就可以把 ID 号为 33 的车辆的当前经纬度位置存入 GEO 集合中：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEOADD cars:locations <span class="token number">116.034579</span> <span class="token number">39.030452</span> <span class="token number">33</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>当用户想要寻找自己附近的网约车时，LBS 应用就可以使用 GEORADIUS 命令。</p><p>例如，LBS 应用执行下面的命令时，Redis 会根据输入的用户的经纬度信息（116.054579，39.030452），查找以这个经纬度为中心的 5 公里内的车辆信息，并返回给 LBS 应用。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>GEORADIUS cars:locations <span class="token number">116.054579</span> <span class="token number">39.030452</span> <span class="token number">5</span> km ASC COUNT <span class="token number">10</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h2 id="stream" tabindex="-1"><a class="header-anchor" href="#stream" aria-hidden="true">#</a> Stream</h2><h3 id="stream-简介" tabindex="-1"><a class="header-anchor" href="#stream-简介" aria-hidden="true">#</a> Stream 简介</h3><p>Redis Stream 是 Redis 5.0 版本新增加的数据类型，Redis 专门为消息队列设计的数据类型。</p><p>在 Redis 5.0 Stream 没出来之前，消息队列的实现方式都有着各自的缺陷，例如：</p><ul><li>发布订阅模式，不能持久化也就无法可靠的保存消息，并且对于离线重连的客户端不能读取历史消息的缺陷；</li><li>List 实现消息队列的方式不能重复消费，一个消息消费完就会被删除，而且生产者需要自行实现全局唯一 ID。</li></ul><p>基于以上问题，Redis 5.0 便推出了 Stream 类型也是此版本最重要的功能，用于完美地实现消息队列，它支持消息的持久化、支持自动生成全局唯一 ID、支持 ack 确认消息的模式、支持消费组模式等，让消息队列更加的稳定和可靠。</p><h3 id="stream-命令" tabindex="-1"><a class="header-anchor" href="#stream-命令" aria-hidden="true">#</a> Stream 命令</h3><p>Stream 消息队列操作命令：</p><ul><li>XADD：插入消息，保证有序，可以自动生成全局唯一 ID；</li><li>XLEN：查询消息长度；</li><li>XREAD：用于读取消息，可以按 ID 读取数据；</li><li>XDEL：根据消息 ID 删除消息；</li><li>DEL：删除整个 Stream；</li><li>XRANGE：读取区间消息</li><li>XREADGROUP：按消费组形式读取消息；</li><li>XPENDING 和 XACK： <ul><li>XPENDING 命令可以用来查询每个消费组内所有消费者「已读取、但尚未确认」的消息；</li><li>XACK 命令用于向消息队列确认消息处理已完成；</li></ul></li></ul><h3 id="stream-应用" tabindex="-1"><a class="header-anchor" href="#stream-应用" aria-hidden="true">#</a> Stream 应用</h3><h4 id="消息队列-1" tabindex="-1"><a class="header-anchor" href="#消息队列-1" aria-hidden="true">#</a> 消息队列</h4><p>生产者通过 XADD 命令插入一条消息：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># * 表示让 Redis 为插入的数据自动生成一个全局唯一的 ID</span>
<span class="token comment"># 往名称为 mymq 的消息队列中插入一条消息，消息的键是 name，值是 xiaolin</span>
<span class="token operator">&gt;</span> XADD mymq * name xiaolin
<span class="token string">&quot;1654254953808-0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>插入成功后会返回全局唯一的 ID：&quot;1654254953808-0&quot;。消息的全局唯一 ID 由两部分组成：</p><ul><li>第一部分“1654254953808”是数据插入时，以毫秒为单位计算的当前服务器时间；</li><li>第二部分表示插入消息在当前毫秒内的消息序号，这是从 0 开始编号的。例如，“1654254953808-0”就表示在“1654254953808”毫秒内的第 1 条消息。</li></ul><p>消费者通过 XREAD 命令从消息队列中读取消息时，可以指定一个消息 ID，并从这个消息 ID 的下一条消息开始进行读取（注意是输入消息 ID 的下一条信息开始读取，不是查询输入 ID 的消息）。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 从 ID 号为 1654254953807-0 的消息开始，读取后续的所有消息（示例中一共 1 条）。</span>
<span class="token operator">&gt;</span> XREAD STREAMS mymq <span class="token number">1654254953807</span>-0
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果<strong>想要实现阻塞读（当没有数据时，阻塞住），可以调用 XRAED 时设定 BLOCK 配置项</strong>，实现类似于 BRPOP 的阻塞读取操作。</p><p>比如，下面这命令，设置了 BLOCK 10000 的配置项，10000 的单位是毫秒，表明 XREAD 在读取最新消息时，如果没有消息到来，XREAD 将阻塞 10000 毫秒（即 10 秒），然后再返回。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 命令最后的“$”符号表示读取最新的消息</span>
<span class="token operator">&gt;</span> XREAD BLOCK <span class="token number">10000</span> STREAMS mymq $
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">10</span>.00s<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Stream 的基础方法，使用 xadd 存入消息和 xread 循环阻塞读取消息的方式可以实现简易版的消息队列，交互流程如下图所示：</p><blockquote><p>前面介绍的这些操作 List 也支持的，接下来看看 Stream 特有的功能。</p></blockquote><p>Stream 可以以使用 <strong>XGROUP 创建消费组</strong>，创建消费组之后，Stream 可以使用 XREADGROUP 命令让消费组内的消费者读取消息。</p><p>创建两个消费组，这两个消费组消费的消息队列是 mymq，都指定从第一条消息开始读取：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 创建一个名为 group1 的消费组，0-0 表示从第一条消息开始读取。</span>
<span class="token operator">&gt;</span> XGROUP CREATE mymq group1 <span class="token number">0</span>-0
OK
<span class="token comment"># 创建一个名为 group2 的消费组，0-0 表示从第一条消息开始读取。</span>
<span class="token operator">&gt;</span> XGROUP CREATE mymq group2 <span class="token number">0</span>-0
OK
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>消费组 group1 内的消费者 consumer1 从 mymq 消息队列中读取所有消息的命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 命令最后的参数“&gt;”，表示从第一条尚未被消费的消息开始读取。</span>
<span class="token operator">&gt;</span> XREADGROUP GROUP group1 consumer1 STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>消息队列中的消息一旦被消费组里的一个消费者读取了，就不能再被该消费组内的其他消费者读取了，即同一个消费组里的消费者不能消费同一条消息</strong>。</p><p>比如说，我们执行完刚才的 XREADGROUP 命令后，再执行一次同样的命令，此时读到的就是空值了：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XREADGROUP GROUP group1 consumer1 STREAMS mymq <span class="token operator">&gt;</span>
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是，<strong>不同消费组的消费者可以消费同一条消息（但是有前提条件，创建消息组的时候，不同消费组指定了相同位置开始读取消息）</strong>。</p><p>比如说，刚才 group1 消费组里的 consumer1 消费者消费了一条 id 为 1654254953808-0 的消息，现在用 group2 消费组里的 consumer1 消费者消费消息：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XREADGROUP GROUP group2 consumer1 STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>因为我创建两组的消费组都是从第一条消息开始读取，所以可以看到第二组的消费者依然可以消费 id 为 1654254953808-0 的这一条消息。因此，不同的消费组的消费者可以消费同一条消息。</p><p>使用消费组的目的是让组内的多个消费者共同分担读取消息，所以，我们通常会让每个消费者读取部分消息，从而实现消息读取负载在多个消费者间是均衡分布的。</p><p>例如，我们执行下列命令，让 group2 中的 consumer1、2、3 各自读取一条消息。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 让 group2 中的 consumer1 从 mymq 消息队列中消费一条消息</span>
<span class="token operator">&gt;</span> XREADGROUP GROUP group2 consumer1 COUNT <span class="token number">1</span> STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolin&quot;</span>
<span class="token comment"># 让 group2 中的 consumer2 从 mymq 消息队列中消费一条消息</span>
<span class="token operator">&gt;</span> XREADGROUP GROUP group2 consumer2 COUNT <span class="token number">1</span> STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654256265584-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;xiaolincoding&quot;</span>
<span class="token comment"># 让 group2 中的 consumer3 从 mymq 消息队列中消费一条消息</span>
<span class="token operator">&gt;</span> XREADGROUP GROUP group2 consumer3 COUNT <span class="token number">1</span> STREAMS mymq <span class="token operator">&gt;</span>
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;mymq&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654256271337-0&quot;</span>
         <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
            <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;Tom&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>基于 Stream 实现的消息队列，如何保证消费者在发生故障或宕机再次重启后，仍然可以读取未处理完的消息？</p></blockquote><p>Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令通知 Streams“消息已经处理完成”。</p><p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 XACK 命令确认消息已经被消费完成，整个流程的执行如下图所示：</p><p>如果消费者没有成功处理消息，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。此时，<strong>消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息</strong>。</p><p>例如，我们来查看一下 group2 中各个消费者已读取、但尚未确认的消息个数，命令如下：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> XPENDING mymq group2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1654254953808-0&quot;</span>  <span class="token comment"># 表示 group2 中所有消费者读取的消息最小 ID</span>
<span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">&quot;1654256271337-0&quot;</span>  <span class="token comment"># 表示 group2 中所有消费者读取的消息最大 ID</span>
<span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;consumer1&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;consumer2&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;consumer3&quot;</span>
      <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;1&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果想查看某个消费者具体读取了哪些数据，可以执行下面的命令：</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 查看 group2 里 consumer2 已从 mymq 消息队列中读取了哪些消息</span>
<span class="token operator">&gt;</span> XPENDING mymq group2 - + <span class="token number">10</span> consumer2
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;1654256265584-0&quot;</span>
   <span class="token number">2</span><span class="token punctuation">)</span> <span class="token string">&quot;consumer2&quot;</span>
   <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">410700</span>
   <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以看到，consumer2 已读取的消息的 ID 是 1654256265584-0。</p><p><strong>一旦消息 1654256265584-0 被 consumer2 处理了，consumer2 就可以使用 XACK 命令通知 Streams，然后这条消息就会被删除</strong>。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XACK mymq group2 <span class="token number">1654256265584</span>-0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当我们再使用 XPENDING 命令查看时，就可以看到，consumer2 已经没有已读取、但尚未确认处理的消息了。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&gt;</span> XPENDING mymq group2 - + <span class="token number">10</span> consumer2
<span class="token punctuation">(</span>empty array<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>好了，基于 Stream 实现的消息队列就说到这里了，小结一下：</p><ul><li>消息保序：XADD/XREAD</li><li>阻塞读取：XREAD block</li><li>重复消息处理：Stream 在使用 XADD 命令，会自动生成全局唯一 ID；</li><li>消息可靠性：内部使用 PENDING List 自动保存消息，使用 XPENDING 命令查看消费组已经读取但是未被确认的消息，消费者使用 XACK 确认消息；</li><li>支持消费组形式消费数据</li></ul><blockquote><p>Redis 基于 Stream 消息队列与专业的消息队列有哪些差距？</p></blockquote><p>一个专业的消息队列，必须要做到两大块：</p><ul><li>消息不丢。</li><li>消息可堆积。</li></ul><p><em>1、Redis Stream 消息会丢失吗？</em></p><p>使用一个消息队列，其实就分为三大块：<strong>生产者、队列中间件、消费者</strong>，所以要保证消息就是保证三个环节都不能丢失数据。</p><p>Redis Stream 消息队列能不能保证三个环节都不丢失数据？</p>`,90),D=n("li",null,"Redis 生产者会不会丢消息？生产者会不会丢消息，取决于生产者对于异常情况的处理是否合理。从消息被生产出来，然后提交给 MQ 的过程中，只要能正常收到（MQ 中间件）的 ack 确认响应，就表示发送成功，所以只要处理好返回值和异常，如果返回异常则进行消息重发，那么这个阶段是不会出现消息丢失的。",-1),x=n("li",null,"Redis 消费者会不会丢消息？不会，因为 Stream（MQ 中间件）会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，但是未被确认的消息。消费者可以在重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。等到消费者执行完业务逻辑后，再发送消费确认 XACK 命令，也能保证消息的不丢失。",-1),f=n("strong",null,"会",-1),L=n("li",null,"AOF 持久化配置为每秒写盘，但这个写盘过程是异步的，Redis 宕机时会存在数据丢失的可能",-1),O={href:"https://xiaolincoding.com/redis/cluster/master_slave_replication.html#redis-%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1",target:"_blank",rel:"noopener noreferrer"},B=t("<p>可以看到，Redis 在队列中间件环节无法保证消息不丢。像 RabbitMQ 或 Kafka 这类专业的队列中间件，在使用时是部署一个集群，生产者在发布消息时，队列中间件通常会写「多个节点」，也就是有多个副本，这样一来，即便其中一个节点挂了，也能保证集群的数据不丢失。</p><p><em>2、Redis Stream 消息可堆积吗？</em></p><p>Redis 的数据都存储在内存中，这就意味着一旦发生消息积压，则会导致 Redis 的内存持续增长，如果超过机器内存上限，就会面临被 OOM 的风险。</p><p>所以 Redis 的 Stream 提供了可以指定队列最大长度的功能，就是为了避免这种情况发生。</p><p>当指定队列最大长度时，队列长度超过上限后，旧消息会被删除，只保留固定长度的新消息。这么来看，Stream 在消息积压时，如果指定了最大长度，还是有可能丢失消息的。</p><p>但 Kafka、RabbitMQ 专业的消息队列它们的数据都是存储在磁盘上，当消息积压时，无非就是多占用一些磁盘空间。</p><p>因此，把 Redis 当作队列来使用时，会面临的 2 个问题：</p><ul><li>Redis 本身可能会丢数据；</li><li>面对消息挤压，内存资源会紧张；</li></ul><p>所以，能不能将 Redis 作为消息队列来使用，关键看你的业务场景：</p><ul><li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li><li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li></ul><blockquote><p>补充：Redis 发布/订阅机制为什么不可以作为消息队列？</p></blockquote><p>发布订阅机制存在以下缺点，都是跟丢失数据有关：</p><ol><li>发布/订阅机制没有基于任何数据类型实现，所以不具备「数据持久化」的能力，也就是发布/订阅机制的相关操作，不会写入到 RDB 和 AOF 中，当 Redis 宕机重启，发布/订阅机制的数据也会全部丢失。</li><li>发布订阅模式是“发后既忘”的工作模式，如果有订阅者离线重连之后不能消费之前的历史消息。</li><li>当消费端有一定的消息积压时，也就是生产者发送的消息，消费者消费不过来时，如果超过 32M 或者是 60s 内持续保持在 8M 以上，消费端会被强行断开，这个参数是在配置文件中设置的，默认值是 <code>client-output-buffer-limit pubsub 32mb 8mb 60</code>。</li></ol>",13),I={href:"https://xiaolincoding.com/redis/cluster/sentinel.html#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E6%98%AF%E5%A6%82%E4%BD%95%E7%BB%84%E6%88%90%E7%9A%84",target:"_blank",rel:"noopener noreferrer"},T=t('<h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>Redis 常见的五种数据类型：<strong>String（字符串），Hash（哈希），List（列表），Set（集合）及 Zset(sorted set：有序集合)</strong>。</p><p>这五种数据类型都由多种数据结构实现的，主要是出于时间和空间的考虑，当数据量小的时候使用更简单的数据结构，有利于节省内存，提高性能。</p><p>这五种数据类型与底层数据结构对应关系图如下，左边是 Redis 3.0 版本的，也就是《Redis 设计与实现》这本书讲解的版本，现在看还是有点过时了，右边是现在 Github 最新的 Redis 代码的。</p><p>可以看到，Redis 数据类型的底层数据结构随着版本的更新也有所不同，比如：</p><ul><li>在 Redis 3.0 版本中 List 对象的底层数据结构由「双向链表」或「压缩表列表」实现，但是在 3.2 版本之后，List 数据类型底层数据结构是由 quicklist 实现的；</li><li>在最新的 Redis 代码中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</li></ul><p>Redis 五种数据类型的应用场景：</p><ul><li>String 类型的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。</li><li>List 类型的应用场景：消息队列（有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。</li><li>Hash 类型：缓存对象、购物车等。</li><li>Set 类型：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。</li><li>Zset 类型：排序场景，比如排行榜、电话和姓名排序等。</li></ul><p>Redis 后续版本又支持四种数据类型，它们的应用场景如下：</p><ul><li>BitMap（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；</li><li>HyperLogLog（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；</li><li>GEO（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；</li><li>Stream（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。</li></ul><p>针对 Redis 是否适合做消息队列，关键看你的业务场景：</p><ul><li>如果你的业务场景足够简单，对于数据丢失不敏感，而且消息积压概率比较小的情况下，把 Redis 当作队列是完全可以的。</li><li>如果你的业务有海量消息，消息积压的概率比较大，并且不能接受数据丢失，那么还是用专业的消息队列中间件吧。</li></ul><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',13),A={href:"https://redis.io/",target:"_blank",rel:"noopener noreferrer"},N={href:"http://redis.cn/",target:"_blank",rel:"noopener noreferrer"},P={href:"https://item.jd.com/11791607.html",target:"_blank",rel:"noopener noreferrer"},G={href:"https://item.jd.com/11486101.html",target:"_blank",rel:"noopener noreferrer"},H={href:"https://blog.csdn.net/u011957758/article/details/74783347",target:"_blank",rel:"noopener noreferrer"},_={href:"http://blog.getspool.com/2011/11/29/fast-easy-realtime-metrics-using-redis-BitMap/",target:"_blank",rel:"noopener noreferrer"},M={href:"https://xiaolincoding.com/redis/data_struct/command.html#string",target:"_blank",rel:"noopener noreferrer"};function C(X,Z){const a=p("ExternalLinkIcon");return o(),l("div",null,[d,n("blockquote",null,[n("p",null,[s("更多命令请参考："),n("a",r,[s("Redis String 类型官方命令文档"),e(a)])])]),u,s(" ## Hash "),m,n("blockquote",null,[n("p",null,[s("更多命令请参考："),n("a",v,[s("Redis Hash 类型官方命令文档"),e(a)])])]),b,n("blockquote",null,[n("p",null,[s("更多命令请参考："),n("a",k,[s("Redis List 类型官方命令文档"),e(a)])])]),g,n("blockquote",null,[n("p",null,[s("更多命令请参考："),n("a",h,[s("Redis Set 类型官方命令文档"),e(a)])])]),S,n("blockquote",null,[n("p",null,[s("更多命令请参考："),n("a",q,[s("Redis ZSet 类型官方命令文档"),e(a)])])]),y,n("p",null,[s("HyperLogLog 的实现涉及到很多数学问题，太费脑子了，我也没有搞懂，如果你想了解一下，课下可以看看这个："),n("a",E,[s("HyperLogLog"),e(a)]),s("。")]),R,n("ul",null,[D,x,n("li",null,[s("Redis 消息中间件会不会丢消息？"),f,s("，Redis 在以下 2 个场景下，都会导致数据丢失： "),n("ul",null,[L,n("li",null,[s("主从复制也是异步的，"),n("a",O,[s("主从切换时，也存在丢失数据的可能"),e(a)]),s("。")])])])]),B,n("p",null,[s("所以，发布/订阅机制只适合即时通讯的场景，比如"),n("a",I,[s("构建哨兵集群"),e(a)]),s("的场景采用了发布/订阅机制。")]),T,n("ul",null,[n("li",null,[n("a",A,[s("Redis 官网"),e(a)])]),n("li",null,[n("a",N,[s("Redis 官方文档中文版"),e(a)])]),n("li",null,[n("a",P,[s("《Redis 实战》"),e(a)])]),n("li",null,[n("a",G,[s("《Redis 设计与实现》"),e(a)])]),n("li",null,[n("a",H,[s("一看就懂系列之 详解 redis 的 bitmap 在亿级项目中的应用"),e(a)])]),n("li",null,[n("a",_,[s("Fast, easy, realtime metrics using Redis BitMap"),e(a)])]),n("li",null,[n("a",M,[s("Redis 常见数据类型和应用场景"),e(a)])])])])}const K=i(c,[["render",C],["__file","02.Redis数据类型.html.vue"]]);export{K as default};
