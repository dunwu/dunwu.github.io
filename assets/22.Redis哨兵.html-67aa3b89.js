import{_ as r}from"./plugin-vue_export-helper-c27b6911.js";import{r as s,o as d,c as l,a as e,b as n,d as t,e as i}from"./app-4f05975a.js";const a={},g=e("h1",{id:"redis-哨兵",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#redis-哨兵","aria-hidden":"true"},"#"),n(" Redis 哨兵")],-1),c=e("p",null,[n("Redis 哨兵（Sentinel）是 Redis 的"),e("strong",null,"高可用性"),n("（High Availability）解决方案。")],-1),p={href:"https://dunwu.github.io/blog/pages/4907dc/",target:"_blank",rel:"noopener noreferrer"},h=e("p",null,[n("关键词："),e("code",null,"高可用"),n("、"),e("code",null,"监控"),n("、"),e("code",null,"选主"),n("、"),e("code",null,"故障转移"),n("、"),e("code",null,"Raft")],-1),u=i(`<figure><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200713072747.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="哨兵简介" tabindex="-1"><a class="header-anchor" href="#哨兵简介" aria-hidden="true">#</a> 哨兵简介</h2><p>Redis 哨兵（Sentinel）是 Redis 的<strong>高可用性</strong>（High Availability）解决方案：由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器；并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>Sentinel 的主要功能如下：</p><ul><li><strong><code>监控（Monitoring）</code></strong> - Sentinel 不断检查主从服务器是否正常在工作。</li><li><strong><code>通知（Notification）</code></strong> - Sentinel 可以通过一个 api 来通知系统管理员或者另外的应用程序，被监控的 Redis 实例有一些问题。</li><li><strong><code>自动故障转移（Automatic Failover）</code></strong> - 如果一个主服务器下线，Sentinel 会开始自动故障转移：把一个从节点提升为主节点，并重新配置其他的从节点使用新的主节点，使用 Redis 服务的应用程序在连接的时候也被通知新的地址。</li><li><strong><code>配置提供者（Configuration provider）</code></strong> - Sentinel 给客户端的服务发现提供来源：对于一个给定的服务，客户端连接到 Sentinels 来寻找当前主节点的地址。当故障转移发生的时候，Sentinel 将报告新的地址。</li></ul><h2 id="启动哨兵" tabindex="-1"><a class="header-anchor" href="#启动哨兵" aria-hidden="true">#</a> 启动哨兵</h2><p>启动一个 Sentinel 可以使用下面任意一条命令，两条命令效果完全相同。</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>redis-sentinel /path/to/sentinel.conf
redis-server /path/to/sentinel.conf <span class="token parameter variable">--sentinel</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当一个 Sentinel 启动时，它需要执行以下步骤：</p><ol><li>初始化服务器。</li><li>使用 Sentinel 专用代码。</li><li>初始化 Sentinel 状态。</li><li>初始化 Sentinel 的主服务器列表。</li><li>创建连向被监视的主服务器的网络连接。</li></ol><p><strong>Sentinel 本质上是一个运行在特殊状模式下的 Redis 服务器</strong>。Sentinel 模式下 Redis 服务器只支持 <code>PING</code>、<code>SENTINEL</code>、<code>INFO</code>、<code>SUBSCRIBE</code>、<code>UNSUBSCRIBE</code>、<code>PSUBSCRIBE</code>、<code>PUNSUBSCRIBE</code> 七个命令。</p><p>创建连向被监视的主服务器的网络连接，Sentinel 将成为主服务器的客户端，它可以向主服务器发送命令，并从命令回复中获取相关的信息。Sentinel 会读入用户指定的配置文件， 为每个要被监视的主服务器创建相应的实例结构， 并创建连向主服务器的命令连接和订阅连接：</p><ul><li><strong>命令连接</strong> - 专门用于向主服务器发送命令，并接受命令回复。</li><li><strong>订阅连接</strong> - 专门用于订阅主服务器的 <code>__sentinel__:hello</code> 频道。</li></ul><h2 id="监控" tabindex="-1"><a class="header-anchor" href="#监控" aria-hidden="true">#</a> 监控</h2><h3 id="获取服务器信息" tabindex="-1"><a class="header-anchor" href="#获取服务器信息" aria-hidden="true">#</a> 获取服务器信息</h3><blockquote><p><strong>Sentinel 通过向主服务器发送 <code>INFO</code> 命令来获得主服务器属下所有从服务器的地址信息， 并为这些从服务器创建相应的实例结构， 以及连向这些从服务器的命令连接和订阅连接</strong>。</p></blockquote><p>默认情况下， Sentinel 以<strong>每十秒一次</strong>的频率向被监视的主服务器和从服务器发送 <code>INFO</code> 命令，并通过分析 <code>INFO</code> 命令的回复来获取服务器的当前信息。当主服务器处于下线状态， 或 Sentinel 正在对主服务器进行故障转移操作时，Sentinel 向从服务器发送 INFO 命令的频率会改为每秒一次。</p><p>对于监视同一个主服务器和从服务器的多个 Sentinel 来说， 它们会以每两秒一次的频率， 通过向被监视服务器的 <code>__sentinel__:hello</code> 频道发送消息来向其他 Sentinel 宣告自己的存在。Sentinel 只会与主服务器和从服务器创建命令连接和订阅连接， Sentinel 与 Sentinel 之间则只创建命令连接。</p><h3 id="判断下线" tabindex="-1"><a class="header-anchor" href="#判断下线" aria-hidden="true">#</a> 判断下线</h3><blockquote><p>Sentinel 向 Redis 服务器发送 <code>PING</code> 命令，来判断其是否下线。</p></blockquote><ul><li><strong>主观下线</strong>：适用于所有 <strong>主节点</strong> 和 <strong>从节点</strong>。默认情况下，Sentinel 以<strong>每秒一次</strong>的频率向实例（包括主服务器、从服务器、其他 Sentinel）发送 <code>PING</code> 命令 ，根据回复判断其是否在线。当一个实例在指定的时长（ <code>down-after-milliseconds</code> 毫秒）中，未向 Sentinel 发送有效回复时， Sentinel 会将这个实例判定为<strong>主观下线</strong>。</li><li><strong>客观下线</strong>：只适用于 <strong>主节点</strong>。当 Sentinel 将一个主服务器判断为主观下线时， 它会向同样监视这个主服务器的其他 Sentinel 进行询问， 看它们是否同意这个主服务器已经进入主观下线状态。当足够数量的 Sentinel 认为主服务器已下线，就判定其为客观下线， 并发起一次针对主服务器的故障转移。接下来，可以对其执行故障转移操作。 <ul><li><code>Sentinel</code> 节点通过 <code>sentinel is-master-down-by-addr</code> 命令，向其它 <code>Sentinel</code> 节点询问对该节点的 <strong>状态判断</strong>。</li></ul></li></ul><h2 id="选主" tabindex="-1"><a class="header-anchor" href="#选主" aria-hidden="true">#</a> 选主</h2>`,23),f={href:"https://ramcloud.atlassian.net/wiki/download/attachments/6586375/raft.pdf",target:"_blank",rel:"noopener noreferrer"},S={href:"https://dunwu.github.io/blog/pages/4907dc/",target:"_blank",rel:"noopener noreferrer"},m=i('<p><strong>当一个主服务器被判断为客观下线时，监视这个下线主服务器的各个 Sentinel 会进行协商，选举出一个领头的 Sentinel，并由领头 Sentinel 对下线主服务器执行故障转移操作</strong>。</p><p>所有在线 Sentinel 都有资格被选为 Leader。</p><p>每个 <code>Sentinel</code> 节点都需要 <strong>定期执行</strong> 以下任务：</p><p>（1）每个 <code>Sentinel</code> 以 <strong>每秒钟</strong> 一次的频率，向它所知的 <strong>主服务器</strong>、<strong>从服务器</strong> 以及其他 <code>Sentinel</code> <strong>实例</strong> 发送一个 <code>PING</code> 命令。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61df44c4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（2）如果一个 <strong>实例</strong>（<code>instance</code>）距离 <strong>最后一次</strong> 有效回复 <code>PING</code> 命令的时间超过 <code>down-after-milliseconds</code> 所指定的值，那么这个实例会被 <code>Sentinel</code> 标记为 <strong>主观下线</strong>。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce61dc739de?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（3）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，那么正在 <strong>监视</strong> 这个 <strong>主服务器</strong> 的所有 <code>Sentinel</code> 节点，要以 <strong>每秒一次</strong> 的频率确认 <strong>主服务器</strong> 的确进入了 <strong>主观下线</strong> 状态。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647a39535?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（4）如果一个 <strong>主服务器</strong> 被标记为 <strong>主观下线</strong>，并且有 <strong>足够数量</strong> 的 <code>Sentinel</code>（至少要达到 <strong>配置文件</strong> 指定的数量）在指定的 <strong>时间范围</strong> 内同意这一判断，那么这个 <strong>主服务器</strong> 被标记为 <strong>客观下线</strong>。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce647c2583e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（5）在一般情况下， 每个 <code>Sentinel</code> 会以每 <code>10</code> 秒一次的频率，向它已知的所有 <strong>主服务器</strong> 和 <strong>从服务器</strong> 发送 <code>INFO</code> 命令。当一个 <strong>主服务器</strong> 被 <code>Sentinel</code> 标记为 <strong>客观下线</strong> 时，<code>Sentinel</code> 向 <strong>下线主服务器</strong> 的所有 <strong>从服务器</strong> 发送 <code>INFO</code> 命令的频率，会从 <code>10</code> 秒一次改为 <strong>每秒一次</strong>。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6738a30db?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（6）<code>Sentinel</code> 和其他 <code>Sentinel</code> 协商 <strong>主节点</strong> 的状态，如果 <strong>主节点</strong> 处于 <code>SDOWN</code> 状态，则投票自动选出新的 <strong>主节点</strong>。将剩余的 <strong>从节点</strong> 指向 <strong>新的主节点</strong> 进行 <strong>数据复制</strong>。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce676a95a54?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><p>（7）当没有足够数量的 <code>Sentinel</code> 同意 <strong>主服务器</strong> 下线时， <strong>主服务器</strong> 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code> 的 <code>PING</code> 命令返回 <strong>有效回复</strong> 时，<strong>主服务器</strong> 的 <strong>主观下线状态</strong> 就会被移除。</p><figure><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560ce6759c1cb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><blockquote><p>注意：一个有效的 <code>PING</code> 回复可以是：<code>+PONG</code>、<code>-LOADING</code> 或者 <code>-MASTERDOWN</code>。如果 <strong>服务器</strong> 返回除以上三种回复之外的其他回复，又或者在 <strong>指定时间</strong> 内没有回复 <code>PING</code> 命令， 那么 <code>Sentinel</code> 认为服务器返回的回复 <strong>无效</strong>（<code>non-valid</code>）。</p></blockquote><h2 id="故障转移" tabindex="-1"><a class="header-anchor" href="#故障转移" aria-hidden="true">#</a> 故障转移</h2><p>在选举产生出 Sentinel Leader 后，Sentinel Leader 将对已下线的主服务器执行故障转移操作。操作含以下三个步骤：</p><p>（一）<strong>选出新的主服务器</strong></p><p>故障转移第一步，是 Sentinel Leader 在已下线主服务属下的所有从服务器中，挑选一个状态良好、数据完整的从服务器。然后，向这个从服务器发送 <code>SLAVEOF no one</code> 命令，将其转换为主服务器。</p><p>Sentinel Leader 如何选出新的主服务器：</p><ul><li>删除列表中所有处于下线或断线状态的从服务器。</li><li>删除列表中所有最近五秒没有回复过 Sentinel Leader 的 INFO 命令的从服务器。</li><li>删除所有与已下线主服务器连接断开超过 <code>down-after-milliseconds</code> * 10 毫秒的从服务器（<code>down-after-milliseconds</code> 指定了判断主服务器下线所需的时间）。</li><li>之后， Sentinel Leader 先选出优先级最高的从服务器；如果优先级一样高，再选择复制偏移量最大的从服务器；如果结果还不唯一，则选出运行 ID 最小的从服务器。</li></ul><p>（二）<strong>修改从服务器的复制目标</strong></p><p>选出新的主服务器后，Sentinel Leader 会向所有从服务器发送 <code>SLAVEOF</code> 命令，让它们去复制新的主服务器。</p><p>（三）<strong>将旧的主服务器变为从服务器</strong></p><p>Sentinel Leader 将旧的主服务器标记为从服务器。当旧的主服务器重新上线，Sentinel 会向它发送 <code>SLAVEOF</code> 命令，让其成为从服务器。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',29),b={href:"https://item.jd.com/11486101.html",target:"_blank",rel:"noopener noreferrer"},_={href:"http://www.web-lovers.com/redis-source-sentinel.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://juejin.im/post/5b7d226a6fb9a01a1e01ff64",target:"_blank",rel:"noopener noreferrer"};function x(N,R){const o=s("ExternalLinkIcon");return d(),l("div",null,[g,e("blockquote",null,[c,e("p",null,[n("Redis 哨兵是 "),e("a",p,[n("Raft 算法"),t(o)]),n(" 的具体实现。")]),h]),u,e("blockquote",null,[e("p",null,[n("Redis Sentinel 系统选举 Leader 的算法是 "),e("a",f,[n("Raft"),t(o)]),n(" 的实现。")]),e("p",null,[n("Raft 是一种共识性算法，想了解其原理，可以参考 "),e("a",S,[n("深入剖析共识性算法 Raft"),t(o)]),n("。")])]),m,e("ul",null,[e("li",null,[e("a",b,[n("《Redis 设计与实现》"),t(o)])]),e("li",null,[e("a",_,[n("渐进式解析 Redis 源码 - 哨兵 sentinel"),t(o)])]),e("li",null,[e("a",w,[n("深入剖析 Redis 系列(二) - Redis 哨兵模式与高可用集群"),t(o)])])])])}const k=r(a,[["render",x],["__file","22.Redis哨兵.html.vue"]]);export{k as default};
