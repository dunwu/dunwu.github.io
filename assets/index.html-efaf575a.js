const e=JSON.parse('{"key":"v-e1d54788","path":"/pages/2c6488/","title":"Java并发核心机制","lang":"zh-CN","frontmatter":{"title":"Java并发核心机制","date":"2019-12-25T22:19:09.000Z","category":["Java","JavaSE","并发"],"tag":["Java","JavaSE","并发"],"permalink":"/pages/2c6488/","description":"Java 并发核心机制 Java 对于并发的支持主要汇聚在 java.util.concurrent，即 J.U.C。而 J.U.C 的核心是 AQS。 J.U.C 简介 Java 的 java.util.concurrent 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为： 原子类 - 如：AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference 等。 锁 - 如：ReentrantLock、ReentrantReadWriteLock 等。 并发容器 - 如：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。 阻塞队列 - 如：ArrayBlockingQueue、LinkedBlockingQueue 等。 非阻塞队列 - 如： ConcurrentLinkedQueue 、LinkedTransferQueue 等。 Executor 框架（线程池）- 如：ThreadPoolExecutor、Executors 等。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/pages/2c6488/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java并发核心机制"}],["meta",{"property":"og:description","content":"Java 并发核心机制 Java 对于并发的支持主要汇聚在 java.util.concurrent，即 J.U.C。而 J.U.C 的核心是 AQS。 J.U.C 简介 Java 的 java.util.concurrent 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为： 原子类 - 如：AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference 等。 锁 - 如：ReentrantLock、ReentrantReadWriteLock 等。 并发容器 - 如：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。 阻塞队列 - 如：ArrayBlockingQueue、LinkedBlockingQueue 等。 非阻塞队列 - 如： ConcurrentLinkedQueue 、LinkedTransferQueue 等。 Executor 框架（线程池）- 如：ThreadPoolExecutor、Executors 等。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-10T10:35:58.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaSE"}],["meta",{"property":"article:tag","content":"并发"}],["meta",{"property":"article:published_time","content":"2019-12-25T22:19:09.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-10T10:35:58.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java并发核心机制\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-12-25T22:19:09.000Z\\",\\"dateModified\\":\\"2023-09-10T10:35:58.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io\\"}]}"]]},"headers":[{"level":2,"title":"J.U.C 简介","slug":"j-u-c-简介","link":"#j-u-c-简介","children":[]},{"level":2,"title":"synchronized","slug":"synchronized","link":"#synchronized","children":[{"level":3,"title":"synchronized 的应用","slug":"synchronized-的应用","link":"#synchronized-的应用","children":[]},{"level":3,"title":"synchronized 的原理","slug":"synchronized-的原理","link":"#synchronized-的原理","children":[]},{"level":3,"title":"synchronized 的优化","slug":"synchronized-的优化","link":"#synchronized-的优化","children":[]},{"level":3,"title":"synchronized 的误区","slug":"synchronized-的误区","link":"#synchronized-的误区","children":[]}]},{"level":2,"title":"volatile","slug":"volatile","link":"#volatile","children":[{"level":3,"title":"volatile 的要点","slug":"volatile-的要点","link":"#volatile-的要点","children":[]},{"level":3,"title":"volatile 的应用","slug":"volatile-的应用","link":"#volatile-的应用","children":[]},{"level":3,"title":"volatile 的原理","slug":"volatile-的原理","link":"#volatile-的原理","children":[]},{"level":3,"title":"volatile 的问题","slug":"volatile-的问题","link":"#volatile-的问题","children":[]}]},{"level":2,"title":"CAS","slug":"cas","link":"#cas","children":[{"level":3,"title":"CAS 的要点","slug":"cas-的要点","link":"#cas-的要点","children":[]},{"level":3,"title":"CAS 的应用","slug":"cas-的应用","link":"#cas-的应用","children":[]},{"level":3,"title":"CAS 的原理","slug":"cas-的原理","link":"#cas-的原理","children":[]},{"level":3,"title":"CAS 的问题","slug":"cas-的问题","link":"#cas-的问题","children":[]}]},{"level":2,"title":"ThreadLocal","slug":"threadlocal","link":"#threadlocal","children":[{"level":3,"title":"ThreadLocal 的应用","slug":"threadlocal-的应用","link":"#threadlocal-的应用","children":[]},{"level":3,"title":"ThreadLocal 的原理","slug":"threadlocal-的原理","link":"#threadlocal-的原理","children":[]},{"level":3,"title":"ThreadLocal 的误区","slug":"threadlocal-的误区","link":"#threadlocal-的误区","children":[]},{"level":3,"title":"InheritableThreadLocal","slug":"inheritablethreadlocal","link":"#inheritablethreadlocal","children":[]}]},{"level":2,"title":"参考资料","slug":"参考资料","link":"#参考资料","children":[]}],"git":{"createdTime":1694342158000,"updatedTime":1694342158000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":1}]},"readingTime":{"minutes":31.63,"words":9489},"filePathRelative":"01.Java/01.JavaSE/05.并发/03.Java并发核心机制.md","localizedDate":"2019年12月25日","excerpt":"<h1> Java 并发核心机制</h1>\\n<blockquote>\\n<p>Java 对于并发的支持主要汇聚在 <code>java.util.concurrent</code>，即 J.U.C。而 J.U.C 的核心是 <code>AQS</code>。</p>\\n</blockquote>\\n<h2> J.U.C 简介</h2>\\n<p>Java 的 <code>java.util.concurrent</code> 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：</p>\\n<ul>\\n<li>原子类 - 如：<code>AtomicInteger</code>、<code>AtomicIntegerArray</code>、<code>AtomicReference</code>、<code>AtomicStampedReference</code> 等。</li>\\n<li>锁 - 如：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li>\\n<li>并发容器 - 如：<code>ConcurrentHashMap</code>、<code>CopyOnWriteArrayList</code>、<code>CopyOnWriteArraySet</code> 等。</li>\\n<li>阻塞队列 - 如：<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code> 等。</li>\\n<li>非阻塞队列 - 如： <code>ConcurrentLinkedQueue</code> 、<code>LinkedTransferQueue</code> 等。</li>\\n<li><code>Executor</code> 框架（线程池）- 如：<code>ThreadPoolExecutor</code>、<code>Executors</code> 等。</li>\\n</ul>","autoDesc":true}');export{e as data};
