const e=JSON.parse('{"key":"v-79afa964","path":"/pages/3ae455/","title":"分布式 ID 基本原理","lang":"zh-CN","frontmatter":{"title":"分布式 ID 基本原理","date":"2019-07-24T11:55:00.000Z","category":["分布式","分布式调度"],"tag":["分布式","数据调度","分布式ID"],"permalink":"/pages/3ae455/","description":"分布式 ID 基本原理 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。 为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/pages/3ae455/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"分布式 ID 基本原理"}],["meta",{"property":"og:description","content":"分布式 ID 基本原理 传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。 数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。 为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2023-09-08T15:41:08.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"分布式"}],["meta",{"property":"article:tag","content":"数据调度"}],["meta",{"property":"article:tag","content":"分布式ID"}],["meta",{"property":"article:published_time","content":"2019-07-24T11:55:00.000Z"}],["meta",{"property":"article:modified_time","content":"2023-09-08T15:41:08.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"分布式 ID 基本原理\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-07-24T11:55:00.000Z\\",\\"dateModified\\":\\"2023-09-08T15:41:08.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io\\"}]}"]]},"headers":[{"level":2,"title":"1. 分布式 ID 简介","slug":"_1-分布式-id-简介","link":"#_1-分布式-id-简介","children":[]},{"level":2,"title":"2. UUID","slug":"_2-uuid","link":"#_2-uuid","children":[{"level":3,"title":"2.1. UUID 的优点","slug":"_2-1-uuid-的优点","link":"#_2-1-uuid-的优点","children":[]},{"level":3,"title":"2.2. UUID 的缺点","slug":"_2-2-uuid-的缺点","link":"#_2-2-uuid-的缺点","children":[]},{"level":3,"title":"2.3. 适用场景","slug":"_2-3-适用场景","link":"#_2-3-适用场景","children":[]}]},{"level":2,"title":"3. 利用第三方存储生成键","slug":"_3-利用第三方存储生成键","link":"#_3-利用第三方存储生成键","children":[{"level":3,"title":"3.1. 优点","slug":"_3-1-优点","link":"#_3-1-优点","children":[]},{"level":3,"title":"3.2. 缺点","slug":"_3-2-缺点","link":"#_3-2-缺点","children":[]}]},{"level":2,"title":"4. 雪花算法（Snowflake）","slug":"_4-雪花算法-snowflake","link":"#_4-雪花算法-snowflake","children":[{"level":3,"title":"4.1. 基本原理","slug":"_4-1-基本原理","link":"#_4-1-基本原理","children":[]},{"level":3,"title":"4.2. 优点","slug":"_4-2-优点","link":"#_4-2-优点","children":[]},{"level":3,"title":"4.3. 缺点","slug":"_4-3-缺点","link":"#_4-3-缺点","children":[]},{"level":3,"title":"4.4. 适用场景","slug":"_4-4-适用场景","link":"#_4-4-适用场景","children":[]},{"level":3,"title":"4.5. 防止时钟回拨","slug":"_4-5-防止时钟回拨","link":"#_4-5-防止时钟回拨","children":[]}]},{"level":2,"title":"5. Leaf","slug":"_5-leaf","link":"#_5-leaf","children":[{"level":3,"title":"5.1. 基本原理","slug":"_5-1-基本原理","link":"#_5-1-基本原理","children":[]},{"level":3,"title":"5.2. 优点","slug":"_5-2-优点","link":"#_5-2-优点","children":[]},{"level":3,"title":"5.3. 缺点","slug":"_5-3-缺点","link":"#_5-3-缺点","children":[]},{"level":3,"title":"5.4. 适用场景","slug":"_5-4-适用场景","link":"#_5-4-适用场景","children":[]}]},{"level":2,"title":"6. 参考资料","slug":"_6-参考资料","link":"#_6-参考资料","children":[]}],"git":{"createdTime":1694186720000,"updatedTime":1694187668000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":11.98,"words":3594},"filePathRelative":"15.分布式/12.分布式调度/04.分布式ID.md","localizedDate":"2019年7月24日","excerpt":"<h1> 分布式 ID 基本原理</h1>\\n<blockquote>\\n<p>传统数据库软件开发中，主键自动生成技术是基本需求。而各个数据库对于该需求也提供了相应的支持，比如 MySQL 的自增键，Oracle 的自增序列等。</p>\\n<p>数据分片后，不同数据节点生成全局唯一主键是非常棘手的问题。同一个逻辑表内的不同实际表之间的自增键由于无法互相感知而产生重复主键。 虽然可通过约束自增主键初始值和步长的方式避免碰撞，但需引入额外的运维规则，使解决方案缺乏完整性和可扩展性。</p>\\n<p>为此，需要使用分布式 ID 来解决此问题。本文总结业界常用的分布式 ID 解决方案。</p>\\n</blockquote>","autoDesc":true}');export{e as data};
