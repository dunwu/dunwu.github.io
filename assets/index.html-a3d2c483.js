const l=JSON.parse('{"key":"v-ce70315c","path":"/pages/d71f2c/","title":"Java 编程规范","lang":"zh-CN","frontmatter":{"title":"Java 编程规范","date":"2019-05-06T15:02:02.000Z","order":99,"permalink":"/pages/d71f2c/","category":["Java","JavaSE","高级特性"],"tag":["Java","JavaSE"],"description":"Java 编程规范 编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。 Effective Java 第 2 章 创建、销毁对象 第 1 条：考虑用静态工厂方法代替构造器 第 2 条：遇到多个构造器参数时要考虑用构建器 第 3 条：用私有构造器或者枚举类型强化 Singleton 属性 第 4 条：通过私有构造器强化不可实例化的能力 第 5 条：避免创建不必要的对象 第 6 条：消除过期的对象引用 第 7 条：避免使用终结方法 第 3 章 对于所有对象都通用的方法 第 8 条：覆盖 equals 时请遵守通用约定 第 9 条：覆盖 equals 时总要覆盖 hashCode 第 10 条：始终要覆盖 toString 第 11 条：谨慎地覆盖 clone 第 12 条：考虑实现 Comparable 接口 第 4 章 类和接口 第 13 条：使类和成员的可访问性最小化 第 14 条：在公有类中使用访问方法而非公有域 第 15 条：使可变性最小化 第 16 条：复合优先于继承 第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承 第 18 条：接口优于抽象类 第 19 条：接口只用于定义类型 第 20 条：类层次优于标签类 第 21 条：用函数对象表示策略 第 22 条：优先考虑静态成员类 第 5 章 泛型 第 23 条：请不要在新代码中使用原生态类型 第 24 条：消除非受检警告 第 25 条：列表优先于数组 第 26 条：优先考虑泛型 第 27 条：优先考虑泛型方法 第 28 条：利用有限制通配符来提升 API 的灵活性 第 29 条：优先考虑类型安全的异构容器 第 6 章 枚举和注解 第 30 条：用 enum 代替 int 常量 第 31 条：用实例域代替序数 第 32 条：用 EnumSet 代替位域 第 33 条：用 EnumMap 代替序数索引 第 34 条：用接口模拟可伸缩的枚举 第 35 条：注解优先于命名模式 第 36 条：坚持使用 Override 注解 第 37 条：用标记接口定义类型 第 7 章 方法 第 38 条：检查参数的有效性 第 39 条：必要时进行保护性拷贝 第 40 条：谨慎设计方法签名 第 41 条：慎用重载 第 42 条：慎用可变参数 第 43 条：返回零长度的数组或者集合，而不是：null 第 44 条：为所有导出的 API 元素编写文档注释 第 8 章 通用程序设计 第 45 条：将局部变量的作用域最小化 第 46 条：for-each 循环优先于传统的 for 循环 第 47 条：了解和使用类库 第 48 条：如果需要精确的答案，请避免使用 float 和 double 第 49 条：基本类型优先于装箱基本类型 第 50 条：如果其他类型更适合，则尽量避免使用字符串 第 51 条：当心字符串连接的性能 第 52 条：通过接口引用对象 第 53 条：接口优先于反射机制 第 54 条：谨慎地使用本地方法 第 55 条：谨慎地进行优化 第 56 条：遵守普遍接受的命名惯例 第 9 章 异常 第 57 条：只针对异常的情况才使用异常 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 第 59 条：避免不必要地使用受检的异常 第 60 条：优先使用标准的异常 第 61 条：抛出与抽象相对应的异常 第 62 条：每个方法抛出的异常都要有文档 第 63 条：在细节消息中包含能捕获失败的信息 第 64 条：努力使失败保持原子性 第 65 条：不要忽略异常 第 10 章 并发 第 66 条：同步访问共享的可变数据 第 67 条：避免过度同步 第 68 条：executor 和 task 优先干线程 第 69 条：并发工具优先于 wait 和 notify 第 70 条：线程安全性的文档化 第 71 条：慎用延迟初始化 第 72 条：不要依赖于线程调度器 第 73 条：避免使用线程组 第 11 章 序列化 第 74 条：谨慎地实现 Serializable 接口 第 75 条：考虑使用自定义的序列化形式 第 76 条：保护性地编写 readObject 方法 第 77 条：对于实例控制，枚举类型优先于 readResolve 第 78 条：考虑用序列化代理代替序列化实例","head":[["meta",{"property":"og:url","content":"https://dunwu.github.io/pages/d71f2c/"}],["meta",{"property":"og:site_name","content":"钝悟"}],["meta",{"property":"og:title","content":"Java 编程规范"}],["meta",{"property":"og:description","content":"Java 编程规范 编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。 Effective Java 第 2 章 创建、销毁对象 第 1 条：考虑用静态工厂方法代替构造器 第 2 条：遇到多个构造器参数时要考虑用构建器 第 3 条：用私有构造器或者枚举类型强化 Singleton 属性 第 4 条：通过私有构造器强化不可实例化的能力 第 5 条：避免创建不必要的对象 第 6 条：消除过期的对象引用 第 7 条：避免使用终结方法 第 3 章 对于所有对象都通用的方法 第 8 条：覆盖 equals 时请遵守通用约定 第 9 条：覆盖 equals 时总要覆盖 hashCode 第 10 条：始终要覆盖 toString 第 11 条：谨慎地覆盖 clone 第 12 条：考虑实现 Comparable 接口 第 4 章 类和接口 第 13 条：使类和成员的可访问性最小化 第 14 条：在公有类中使用访问方法而非公有域 第 15 条：使可变性最小化 第 16 条：复合优先于继承 第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承 第 18 条：接口优于抽象类 第 19 条：接口只用于定义类型 第 20 条：类层次优于标签类 第 21 条：用函数对象表示策略 第 22 条：优先考虑静态成员类 第 5 章 泛型 第 23 条：请不要在新代码中使用原生态类型 第 24 条：消除非受检警告 第 25 条：列表优先于数组 第 26 条：优先考虑泛型 第 27 条：优先考虑泛型方法 第 28 条：利用有限制通配符来提升 API 的灵活性 第 29 条：优先考虑类型安全的异构容器 第 6 章 枚举和注解 第 30 条：用 enum 代替 int 常量 第 31 条：用实例域代替序数 第 32 条：用 EnumSet 代替位域 第 33 条：用 EnumMap 代替序数索引 第 34 条：用接口模拟可伸缩的枚举 第 35 条：注解优先于命名模式 第 36 条：坚持使用 Override 注解 第 37 条：用标记接口定义类型 第 7 章 方法 第 38 条：检查参数的有效性 第 39 条：必要时进行保护性拷贝 第 40 条：谨慎设计方法签名 第 41 条：慎用重载 第 42 条：慎用可变参数 第 43 条：返回零长度的数组或者集合，而不是：null 第 44 条：为所有导出的 API 元素编写文档注释 第 8 章 通用程序设计 第 45 条：将局部变量的作用域最小化 第 46 条：for-each 循环优先于传统的 for 循环 第 47 条：了解和使用类库 第 48 条：如果需要精确的答案，请避免使用 float 和 double 第 49 条：基本类型优先于装箱基本类型 第 50 条：如果其他类型更适合，则尽量避免使用字符串 第 51 条：当心字符串连接的性能 第 52 条：通过接口引用对象 第 53 条：接口优先于反射机制 第 54 条：谨慎地使用本地方法 第 55 条：谨慎地进行优化 第 56 条：遵守普遍接受的命名惯例 第 9 章 异常 第 57 条：只针对异常的情况才使用异常 第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常 第 59 条：避免不必要地使用受检的异常 第 60 条：优先使用标准的异常 第 61 条：抛出与抽象相对应的异常 第 62 条：每个方法抛出的异常都要有文档 第 63 条：在细节消息中包含能捕获失败的信息 第 64 条：努力使失败保持原子性 第 65 条：不要忽略异常 第 10 章 并发 第 66 条：同步访问共享的可变数据 第 67 条：避免过度同步 第 68 条：executor 和 task 优先干线程 第 69 条：并发工具优先于 wait 和 notify 第 70 条：线程安全性的文档化 第 71 条：慎用延迟初始化 第 72 条：不要依赖于线程调度器 第 73 条：避免使用线程组 第 11 章 序列化 第 74 条：谨慎地实现 Serializable 接口 第 75 条：考虑使用自定义的序列化形式 第 76 条：保护性地编写 readObject 方法 第 77 条：对于实例控制，枚举类型优先于 readResolve 第 78 条：考虑用序列化代理代替序列化实例"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-05-15T22:46:25.000Z"}],["meta",{"property":"article:author","content":"钝悟"}],["meta",{"property":"article:tag","content":"Java"}],["meta",{"property":"article:tag","content":"JavaSE"}],["meta",{"property":"article:published_time","content":"2019-05-06T15:02:02.000Z"}],["meta",{"property":"article:modified_time","content":"2024-05-15T22:46:25.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Java 编程规范\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2019-05-06T15:02:02.000Z\\",\\"dateModified\\":\\"2024-05-15T22:46:25.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"钝悟\\",\\"url\\":\\"https://dunwu.github.io\\"}]}"]]},"headers":[{"level":2,"title":"Effective Java","slug":"effective-java","link":"#effective-java","children":[]},{"level":2,"title":"资源","slug":"资源","link":"#资源","children":[]}],"git":{"createdTime":1694447058000,"updatedTime":1715813185000,"contributors":[{"name":"dunwu","email":"forbreak@163.com","commits":2}]},"readingTime":{"minutes":4.08,"words":1225},"filePathRelative":"01.Java/01.JavaSE/02.高级特性/99.Java编程规范.md","localizedDate":"2019年5月6日","excerpt":"<h1> Java 编程规范</h1>\\n<blockquote>\\n<p>编程规范就是 Java 开发的最佳实践。帮助开发人员少走弯路。</p>\\n</blockquote>\\n<h2> Effective Java</h2>\\n<ul>\\n<li>第 2 章 创建、销毁对象\\n<ul>\\n<li>第 1 条：考虑用静态工厂方法代替构造器</li>\\n<li>第 2 条：遇到多个构造器参数时要考虑用构建器</li>\\n<li>第 3 条：用私有构造器或者枚举类型强化 Singleton 属性</li>\\n<li>第 4 条：通过私有构造器强化不可实例化的能力</li>\\n<li>第 5 条：避免创建不必要的对象</li>\\n<li>第 6 条：消除过期的对象引用</li>\\n<li>第 7 条：避免使用终结方法</li>\\n</ul>\\n</li>\\n<li>第 3 章 对于所有对象都通用的方法\\n<ul>\\n<li>第 8 条：覆盖 equals 时请遵守通用约定</li>\\n<li>第 9 条：覆盖 equals 时总要覆盖 hashCode</li>\\n<li>第 10 条：始终要覆盖 toString</li>\\n<li>第 11 条：谨慎地覆盖 clone</li>\\n<li>第 12 条：考虑实现 Comparable 接口</li>\\n</ul>\\n</li>\\n<li>第 4 章 类和接口\\n<ul>\\n<li>第 13 条：使类和成员的可访问性最小化</li>\\n<li>第 14 条：在公有类中使用访问方法而非公有域</li>\\n<li>第 15 条：使可变性最小化</li>\\n<li>第 16 条：复合优先于继承</li>\\n<li>第 17 条：要么为继承而设计，并提供文档说明，要么就禁止继承</li>\\n<li>第 18 条：接口优于抽象类</li>\\n<li>第 19 条：接口只用于定义类型</li>\\n<li>第 20 条：类层次优于标签类</li>\\n<li>第 21 条：用函数对象表示策略</li>\\n<li>第 22 条：优先考虑静态成员类</li>\\n</ul>\\n</li>\\n<li>第 5 章 泛型\\n<ul>\\n<li>第 23 条：请不要在新代码中使用原生态类型</li>\\n<li>第 24 条：消除非受检警告</li>\\n<li>第 25 条：列表优先于数组</li>\\n<li>第 26 条：优先考虑泛型</li>\\n<li>第 27 条：优先考虑泛型方法</li>\\n<li>第 28 条：利用有限制通配符来提升 API 的灵活性</li>\\n<li>第 29 条：优先考虑类型安全的异构容器</li>\\n</ul>\\n</li>\\n<li>第 6 章 枚举和注解\\n<ul>\\n<li>第 30 条：用 enum 代替 int 常量</li>\\n<li>第 31 条：用实例域代替序数</li>\\n<li>第 32 条：用 EnumSet 代替位域</li>\\n<li>第 33 条：用 EnumMap 代替序数索引</li>\\n<li>第 34 条：用接口模拟可伸缩的枚举</li>\\n<li>第 35 条：注解优先于命名模式</li>\\n<li>第 36 条：坚持使用 Override 注解</li>\\n<li>第 37 条：用标记接口定义类型</li>\\n</ul>\\n</li>\\n<li>第 7 章 方法\\n<ul>\\n<li>第 38 条：检查参数的有效性</li>\\n<li>第 39 条：必要时进行保护性拷贝</li>\\n<li>第 40 条：谨慎设计方法签名</li>\\n<li>第 41 条：慎用重载</li>\\n<li>第 42 条：慎用可变参数</li>\\n<li>第 43 条：返回零长度的数组或者集合，而不是：null</li>\\n<li>第 44 条：为所有导出的 API 元素编写文档注释</li>\\n</ul>\\n</li>\\n<li>第 8 章 通用程序设计\\n<ul>\\n<li>第 45 条：将局部变量的作用域最小化</li>\\n<li>第 46 条：for-each 循环优先于传统的 for 循环</li>\\n<li>第 47 条：了解和使用类库</li>\\n<li>第 48 条：如果需要精确的答案，请避免使用 float 和 double</li>\\n<li>第 49 条：基本类型优先于装箱基本类型</li>\\n<li>第 50 条：如果其他类型更适合，则尽量避免使用字符串</li>\\n<li>第 51 条：当心字符串连接的性能</li>\\n<li>第 52 条：通过接口引用对象</li>\\n<li>第 53 条：接口优先于反射机制</li>\\n<li>第 54 条：谨慎地使用本地方法</li>\\n<li>第 55 条：谨慎地进行优化</li>\\n<li>第 56 条：遵守普遍接受的命名惯例</li>\\n</ul>\\n</li>\\n<li>第 9 章 异常\\n<ul>\\n<li>第 57 条：只针对异常的情况才使用异常</li>\\n<li>第 58 条：对可恢复的情况使用受检异常，对编程错误使用运行时异常</li>\\n<li>第 59 条：避免不必要地使用受检的异常</li>\\n<li>第 60 条：优先使用标准的异常</li>\\n<li>第 61 条：抛出与抽象相对应的异常</li>\\n<li>第 62 条：每个方法抛出的异常都要有文档</li>\\n<li>第 63 条：在细节消息中包含能捕获失败的信息</li>\\n<li>第 64 条：努力使失败保持原子性</li>\\n<li>第 65 条：不要忽略异常</li>\\n</ul>\\n</li>\\n<li>第 10 章 并发\\n<ul>\\n<li>第 66 条：同步访问共享的可变数据</li>\\n<li>第 67 条：避免过度同步</li>\\n<li>第 68 条：executor 和 task 优先干线程</li>\\n<li>第 69 条：并发工具优先于 wait 和 notify</li>\\n<li>第 70 条：线程安全性的文档化</li>\\n<li>第 71 条：慎用延迟初始化</li>\\n<li>第 72 条：不要依赖于线程调度器</li>\\n<li>第 73 条：避免使用线程组</li>\\n</ul>\\n</li>\\n<li>第 11 章 序列化\\n<ul>\\n<li>第 74 条：谨慎地实现 Serializable 接口</li>\\n<li>第 75 条：考虑使用自定义的序列化形式</li>\\n<li>第 76 条：保护性地编写 readObject 方法</li>\\n<li>第 77 条：对于实例控制，枚举类型优先于 readResolve</li>\\n<li>第 78 条：考虑用序列化代理代替序列化实例</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{l as data};
