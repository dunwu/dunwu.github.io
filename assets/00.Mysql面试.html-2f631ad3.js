import{_ as n}from"./plugin-vue_export-helper-c27b6911.js";import{r as d,o as h,c as l,a,b as r,d as i,e as t}from"./app-fcc32256.js";const o={},s=t('<h1 id="mysql-面试" tabindex="-1"><a class="header-anchor" href="#mysql-面试" aria-hidden="true">#</a> Mysql 面试</h1><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><h3 id="一条-sql-查询语句是如何执行的" tabindex="-1"><a class="header-anchor" href="#一条-sql-查询语句是如何执行的" aria-hidden="true">#</a> 一条 SQL 查询语句是如何执行的？</h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720195101.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li><strong>连接器</strong>：连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li><li><strong>查询缓存</strong>：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li><li><strong>分析器</strong><ul><li><strong>词法分析</strong>：解析 SQL 关键字</li><li><strong>语法分析</strong>：生成一颗对应的语法解析树</li></ul></li><li><strong>优化器</strong><ul><li>根据语法树<strong>生成多种执行计划</strong></li><li><strong>索引选择</strong>：根据策略选择最优方式</li></ul></li><li><strong>执行器</strong><ul><li>校验读写权限</li><li>根据执行计划，调用存储引擎的 API 来执行查询</li></ul></li><li><strong>存储引擎</strong>：存储数据，提供读写接口</li></ul><h3 id="一条-sql-更新语句是如何执行的" tabindex="-1"><a class="header-anchor" href="#一条-sql-更新语句是如何执行的" aria-hidden="true">#</a> 一条 SQL 更新语句是如何执行的？</h3><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p><ul><li>redo log（重做日志）</li><li>binlog（归档日志）</li></ul><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h3 id="事务到底是隔离的还是不隔离的" tabindex="-1"><a class="header-anchor" href="#事务到底是隔离的还是不隔离的" aria-hidden="true">#</a> 事务到底是隔离的还是不隔离的</h3><h3 id="快照-在-mvcc-里是怎么工作的" tabindex="-1"><a class="header-anchor" href="#快照-在-mvcc-里是怎么工作的" aria-hidden="true">#</a> “快照”在 MVCC 里是怎么工作的？</h3><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="实现索引有哪些常见数据数据" tabindex="-1"><a class="header-anchor" href="#实现索引有哪些常见数据数据" aria-hidden="true">#</a> 实现索引有哪些常见数据数据？</h3><ul><li>哈希</li><li>有序数组</li><li>B+树</li></ul><h3 id="普通索引和唯一索引-应该怎么选择" tabindex="-1"><a class="header-anchor" href="#普通索引和唯一索引-应该怎么选择" aria-hidden="true">#</a> 普通索引和唯一索引，应该怎么选择？</h3><h3 id="mysql-为什么有时候会选错索引" tabindex="-1"><a class="header-anchor" href="#mysql-为什么有时候会选错索引" aria-hidden="true">#</a> MySQL 为什么有时候会选错索引</h3><h3 id="怎么给字符串字段加索引" tabindex="-1"><a class="header-anchor" href="#怎么给字符串字段加索引" aria-hidden="true">#</a> 怎么给字符串字段加索引？</h3><h2 id="order-by-是怎么工作的" tabindex="-1"><a class="header-anchor" href="#order-by-是怎么工作的" aria-hidden="true">#</a> <code>order by</code> 是怎么工作的？</h2><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><h3 id="全局锁和表锁-给表加个字段怎么有这么多阻碍" tabindex="-1"><a class="header-anchor" href="#全局锁和表锁-给表加个字段怎么有这么多阻碍" aria-hidden="true">#</a> 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？</h3><h3 id="怎么减少行锁对性能的影响" tabindex="-1"><a class="header-anchor" href="#怎么减少行锁对性能的影响" aria-hidden="true">#</a> 怎么减少行锁对性能的影响？</h3><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</p><p>如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><h3 id="什么是死锁-如何检测死锁" tabindex="-1"><a class="header-anchor" href="#什么是死锁-如何检测死锁" aria-hidden="true">#</a> 什么是死锁？如何检测死锁</h3><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为<strong>死锁</strong>。</p><p>当出现死锁以后，有两种策略：</p><ul><li><strong>进入等待，直到超时</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。 <ul><li>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果此策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</li><li>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</li></ul></li><li><strong>发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行</strong>。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑。 <ul><li>主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</li><li>极端情况下，如果所有事务都要更新同一行：每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</li></ul></li></ul><p>减少死锁的主要方向，就是控制访问相同资源的并发事务量。</p><h3 id="为什么我只改一行的语句-锁这么多" tabindex="-1"><a class="header-anchor" href="#为什么我只改一行的语句-锁这么多" aria-hidden="true">#</a> 为什么我只改一行的语句，锁这么多？</h3><h2 id="日志" tabindex="-1"><a class="header-anchor" href="#日志" aria-hidden="true">#</a> 日志</h2><h3 id="为什么表数据删掉一半-表文件大小不变" tabindex="-1"><a class="header-anchor" href="#为什么表数据删掉一半-表文件大小不变" aria-hidden="true">#</a> 为什么表数据删掉一半，表文件大小不变？</h3><p>【问题】数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？</p><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 <code>innodb_file_per_table</code> 控制的：</p><ol><li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ol><p>从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。</p><p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>所以，<strong>将 innodb_file_per_table 设置为 ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。</strong></p><p>我们在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。</p><p><strong>插入和删除操作可能会造成空洞</strong>。</p><ul><li>插入时，如果插入位置所在页已满，需要申请新页面。</li><li>删除时，不会删除所在页，而是将记录在页面的位置标记为可重用。</li></ul><p>所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。</p><p>要达到收缩空洞的目的，可以使用重建表的方式。</p><h2 id="ha" tabindex="-1"><a class="header-anchor" href="#ha" aria-hidden="true">#</a> HA</h2><h3 id="mysql-是怎么保证数据不丢的" tabindex="-1"><a class="header-anchor" href="#mysql-是怎么保证数据不丢的" aria-hidden="true">#</a> Mysql 是怎么保证数据不丢的</h3><h3 id="mysql-是怎么保证主备一致的" tabindex="-1"><a class="header-anchor" href="#mysql-是怎么保证主备一致的" aria-hidden="true">#</a> Mysql 是怎么保证主备一致的</h3><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2><h3 id="count-这么慢-我该怎么办" tabindex="-1"><a class="header-anchor" href="#count-这么慢-我该怎么办" aria-hidden="true">#</a> <code>count(*)</code> 这么慢，我该怎么办？</h3><h3 id="为什么这些-sql-语句逻辑相同-性能却差异巨大" tabindex="-1"><a class="header-anchor" href="#为什么这些-sql-语句逻辑相同-性能却差异巨大" aria-hidden="true">#</a> 为什么这些 SQL 语句逻辑相同，性能却差异巨大？</h3><h3 id="mysql-有哪些-饮鸩止渴-提高性能的方法" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些-饮鸩止渴-提高性能的方法" aria-hidden="true">#</a> MySQL 有哪些“饮鸩止渴”提高性能的方法？</h3><h3 id="如果-mysql-出现了-io-性能瓶颈-可以通过哪些方法来提升性能" tabindex="-1"><a class="header-anchor" href="#如果-mysql-出现了-io-性能瓶颈-可以通过哪些方法来提升性能" aria-hidden="true">#</a> 如果 MySQL 出现了 IO 性能瓶颈，可以通过哪些方法来提升性能</h3><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',51),c={href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"};function b(p,f){const e=d("ExternalLinkIcon");return h(),l("div",null,[s,a("ul",null,[a("li",null,[a("a",c,[r("《高性能 MySQL》"),i(e)])]),a("li",null,[a("a",u,[r("MySQL 实战 45 讲"),i(e)])])])])}const x=n(o,[["render",b],["__file","00.Mysql面试.html.vue"]]);export{x as default};
