import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as i,c as l,a as n,b as a,d as e,e as p}from"./app-c2b0a364.js";const r={},c=p(`<h1 id="mysql-面试" tabindex="-1"><a class="header-anchor" href="#mysql-面试" aria-hidden="true">#</a> Mysql 面试</h1><h2 id="架构" tabindex="-1"><a class="header-anchor" href="#架构" aria-hidden="true">#</a> 架构</h2><h3 id="一条-sql-查询语句是如何执行的" tabindex="-1"><a class="header-anchor" href="#一条-sql-查询语句是如何执行的" aria-hidden="true">#</a> 一条 SQL 查询语句是如何执行的？</h3><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310080719676.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ol><li><strong>连接器</strong>：连接器负责跟客户端建立连接、获取权限、维持和管理连接。</li><li><strong>查询缓存</strong>：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。</li><li><strong>分析器</strong><ul><li><strong>词法分析</strong>：解析 SQL 关键字</li><li><strong>语法分析</strong>：生成一颗对应的语法解析树</li></ul></li><li><strong>优化器</strong><ul><li>根据语法树<strong>生成多种执行计划</strong></li><li><strong>索引选择</strong>：根据策略选择最优方式</li></ul></li><li><strong>执行器</strong><ul><li>校验读写权限</li><li>根据执行计划，调用存储引擎的 API 来执行查询</li></ul></li><li><strong>存储引擎</strong>：存储数据，提供读写接口</li></ol><h3 id="一条-sql-更新语句是如何执行的" tabindex="-1"><a class="header-anchor" href="#一条-sql-更新语句是如何执行的" aria-hidden="true">#</a> 一条 SQL 更新语句是如何执行的？</h3><p>更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：</p><ul><li>redo log（重做日志） <ul><li>InnoDB 存储引擎独有的日志（物理日志）</li><li>采用循环写入</li></ul></li><li><code>binlog</code>（归档日志） <ul><li>Mysql Server 层通用日志（逻辑日志）</li><li>采用追加写入</li></ul></li></ul><p>为了保证 redo log 和 binlog 的数据一致性，所以采用两阶段提交方式更新日志。</p><h3 id="为什么表数据删掉一半-表文件大小不变" tabindex="-1"><a class="header-anchor" href="#为什么表数据删掉一半-表文件大小不变" aria-hidden="true">#</a> 为什么表数据删掉一半，表文件大小不变</h3><p>表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 innodb_file_per_table 控制的：</p><ol><li>这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；</li><li>这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。</li></ol><p>我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。</p><p>要删掉 R4 这个记录，InnoDB 引擎只会把 R4 这个记录标记为删除。如果之后要再插入一个 ID 在 300 和 600 之间的记录时，可能会复用这个位置。但是，磁盘文件的大小并不会缩小。</p><p>如果删掉了一个数据页上的所有记录，则整个数据页就可以被复用了。</p><p>如果把整个表的数据删除，则所有的数据页都会被标记为可复用。但是磁盘上，文件不会变小。</p><p>delete 命令其实只是把记录的位置，或者数据页标记为了“可复用”，但磁盘文件的大小是不会变的。也就是说，通过 delete 命令是不能回收表空间的。这些可以复用，而没有被使用的空间，看起来就像是“空洞”。</p><p>如果数据是按照索引递增顺序插入的，那么索引是紧凑的。但如果数据是随机插入的，就可能造成索引的数据页分裂。页分裂完成后，就可能产生空洞。另外，更新索引上的值，可以理解为删除一个旧的值，再插入一个新值。不难理解，这也是会造成空洞的。</p><p>也就是说，经过大量增删改的表，都是可能是存在空洞的。</p><h3 id="为什么我的-mysql-会-抖-一下" tabindex="-1"><a class="header-anchor" href="#为什么我的-mysql-会-抖-一下" aria-hidden="true">#</a> 为什么我的 MySQL 会“抖”一下？</h3><p>利用 WAL 技术，数据库将随机写转换成了顺序写，大大提升了数据库的性能。</p><p>但是，由此也带来了内存脏页的问题。脏页会被后台线程自动 flush，也会由于数据页淘汰而触发 flush，而刷脏页的过程由于会占用资源，可能会让你的更新和查询语句的响应时间长一些。</p><h3 id="select-语句内部的执行步骤是怎样的" tabindex="-1"><a class="header-anchor" href="#select-语句内部的执行步骤是怎样的" aria-hidden="true">#</a> <code>SELECT</code> 语句内部的执行步骤是怎样的</h3><p>一条完整的 SELECT 语句内部的执行顺序是这样的：</p><ol><li>FROM 子句组装数据（包括通过 ON 进行连接）；</li><li>WHERE 子句进行条件筛选；</li><li>GROUP BY 分组 ；</li><li>使用聚集函数进行计算；</li><li>HAVING 筛选分组；</li><li>计算所有的表达式；</li><li>SELECT 的字段；</li><li>ORDER BY 排序；</li><li>LIMIT 筛选。</li></ol><h3 id="order-by-是对分的组排序还是对分组中的记录排序呢" tabindex="-1"><a class="header-anchor" href="#order-by-是对分的组排序还是对分组中的记录排序呢" aria-hidden="true">#</a> ORDER BY 是对分的组排序还是对分组中的记录排序呢？</h3><p>ORDER BY 就是对记录进行排序。如果你在 ORDER BY 前面用到了 GROUP BY，实际上这是一种分组的聚合方式，已经把一组的数据聚合成为了一条记录，再进行排序的时候，相当于对分的组进行了排序。</p><h3 id="order-by-是怎么工作的" tabindex="-1"><a class="header-anchor" href="#order-by-是怎么工作的" aria-hidden="true">#</a> <code>order by</code> 是怎么工作的？</h3><p>用 explain 命令查看执行计划时，Extra 这个字段中的“Using filesort”表示的就是需要排序。</p><h4 id="全字段排序" tabindex="-1"><a class="header-anchor" href="#全字段排序" aria-hidden="true">#</a> 全字段排序</h4><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> city<span class="token punctuation">,</span>name<span class="token punctuation">,</span>age <span class="token keyword">from</span> t <span class="token keyword">where</span> city<span class="token operator">=</span><span class="token string">&#39;杭州&#39;</span> <span class="token keyword">order</span> <span class="token keyword">by</span> name <span class="token keyword">limit</span> <span class="token number">1000</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个语句执行流程如下所示 ：</p><ol><li>初始化 sort_buffer，确定放入 name、city、age 这三个字段；</li><li>从索引 city 找到第一个满足 city=&#39;杭州’条件的主键 id，也就是图中的 ID_X；</li><li>到主键 id 索引取出整行，取 name、city、age 三个字段的值，存入 sort_buffer 中；</li><li>从索引 city 取下一个记录的主键 id；</li><li>重复步骤 3、4 直到 city 的值不满足查询条件为止，对应的主键 id 也就是图中的 ID_Y；</li><li>对 sort_buffer 中的数据按照字段 name 做快速排序；</li><li>按照排序结果取前 1000 行返回给客户端。</li></ol><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090300.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>按 name 排序”这个动作，可能在内存中完成，也可能需要使用外部排序，这取决于排序所需的内存和参数 sort_buffer_size。如果要排序的数据量小于 sort_buffer_size，排序就在内存中完成。但如果排序数据量太大，内存放不下，则不得不利用磁盘临时文件辅助排序。</p><p>外部排序一般使用归并排序算法。可以这么简单理解，<strong>MySQL 将需要排序的数据分成 N 份，每一份单独排序后存在这些临时文件中。然后把这 N 个有序文件再合并成一个有序的大文件。</strong></p><h4 id="rowid-排序" tabindex="-1"><a class="header-anchor" href="#rowid-排序" aria-hidden="true">#</a> rowid 排序</h4><p>如果表的字段太多，导致单行太大，那么全字段排序的效率就不够好。</p><p>这种情况下，Mysql 可以采用 rowid 排序，相比于全字段排序，它的主要差异在于：</p><p>取行数据时，不取出整行，而只是取出 id 和用于排序的字段。当排序结束后，再根据 id 取出要查询的字段返回给客户端。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220728090919.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="全字段排序-vs-rowid-排序" tabindex="-1"><a class="header-anchor" href="#全字段排序-vs-rowid-排序" aria-hidden="true">#</a> 全字段排序 VS rowid 排序</h4><p>如果内存足够大，Mysql 会优先选择全字段排序，把需要的字段都放到 sort_buffer 中，这样排序后就会直接从内存里面返回查询结果了，不用再回到原表去取数据。</p><p>如果内存太小，会影响排序效率，才会采用 rowid 排序算法，这样排序过程中一次可以排序更多行，但是需要再回到原表去取数据。</p><p>并不是所有的 order by 语句，都需要排序操作的。MySQL 之所以需要生成临时表，并且在临时表上做排序操作，**其原因是原来的数据都是无序的。**如果能保证排序字段命中索引，那么就无需再排序了。</p><p><strong>覆盖索引是指，索引上的信息足够满足查询请求，不需要再回到主键索引上去取数据。</strong></p><h2 id="存储引擎" tabindex="-1"><a class="header-anchor" href="#存储引擎" aria-hidden="true">#</a> 存储引擎</h2><h3 id="mysql-有哪些常见存储引擎" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些常见存储引擎" aria-hidden="true">#</a> Mysql 有哪些常见存储引擎？</h3><ul><li><strong>InnoDB</strong> - Mysql 的默认存储引擎。支持事务、外键、表级锁和行级锁、自动崩溃恢复。索引采用 B+ 树聚簇索引。</li><li><strong>MyISAM</strong> - Mysql 5.1 版本前的默认存储引擎。特性丰富，但不支持事务、外键、行级锁、自动崩溃恢复。索引采用 B+ 树非聚簇索引。</li><li><strong>CSV</strong> - 可以将 CSV 文件作为 Mysql 的表来处理，但这种表不支持索引。</li><li><strong>Memory</strong> - 适合快速访问数据，且数据不会被修改，重启丢失也没有关系。</li><li><strong>NDB</strong> - 用于 Mysql 集群场景。</li></ul><h3 id="都说-innodb-好-那还要不要使用-memory-引擎" tabindex="-1"><a class="header-anchor" href="#都说-innodb-好-那还要不要使用-memory-引擎" aria-hidden="true">#</a> 都说 InnoDB 好，那还要不要使用 Memory 引擎</h3><p>InnoDB 和 Memory 引擎的数据组织方式是不同的：</p><ul><li>InnoDB 引擎把数据放在主键索引上，其他索引上保存的是主键 id。这种方式，我们称之为<strong>索引组织表</strong>（Index Organizied Table）。</li><li>而 Memory 引擎采用的是把数据单独存放，索引上保存数据位置的数据组织形式，我们称之为<strong>堆组织表</strong>（Heap Organizied Table）。</li></ul><p>内存表不支持行锁，只支持表锁。</p><p>数据放在内存中，是内存表的优势，但也是一个劣势。因为，数据库重启的时候，所有的内存表都会被清空。</p><h3 id="innodb-和-myisam-有哪些差异" tabindex="-1"><a class="header-anchor" href="#innodb-和-myisam-有哪些差异" aria-hidden="true">#</a> InnoDB 和 MyISAM 有哪些差异？</h3><table><thead><tr><th>对比项</th><th>MyISAM</th><th>InnoDB</th></tr></thead><tbody><tr><td>主外键</td><td>不支持</td><td>支持</td></tr><tr><td>事务</td><td>不支持</td><td>支持</td></tr><tr><td>锁</td><td>支持表级锁</td><td>支持表级锁、行级锁</td></tr><tr><td>索引</td><td>采用非聚簇索引</td><td>主键采用聚簇索引，以提高 IO 效率</td></tr><tr><td>表空间</td><td>小</td><td>大</td></tr><tr><td>关注点</td><td>性能</td><td>事务</td></tr><tr><td>计数器</td><td>维护了计数器，<code>SELECT COUNT(*)</code> 效率为 <code>O(1)</code></td><td>没有维护计数器，需要全表扫描</td></tr></tbody></table><h2 id="索引" tabindex="-1"><a class="header-anchor" href="#索引" aria-hidden="true">#</a> 索引</h2><h3 id="什么是索引-为什么要使用索引" tabindex="-1"><a class="header-anchor" href="#什么是索引-为什么要使用索引" aria-hidden="true">#</a> 什么是索引？为什么要使用索引？</h3><p><strong>“索引”是数据库为了提高查找效率的一种数据结构</strong>。</p><p>日常生活中，我们可以通过检索目录，来快速定位书本中的内容。索引和数据表，就好比目录和书，想要高效查询数据表，索引至关重要。在数据量小且负载较低时，不恰当的索引对于性能的影响可能还不明显；但随着数据量逐渐增大，性能则会急剧下降。因此，设置合理的索引是数据库查询性能优化的最有效手段。</p><h3 id="索引的优点和缺点是什么" tabindex="-1"><a class="header-anchor" href="#索引的优点和缺点是什么" aria-hidden="true">#</a> 索引的优点和缺点是什么？</h3><p>✔️️️️️️️ 索引的优点：</p><ul><li><strong>索引大大减少了服务器需要扫描的数据量</strong>，从而加快检索速度。</li><li><strong>索引可以帮助服务器避免排序和临时表</strong>。</li><li><strong>索引可以将随机 I/O 变为顺序 I/O</strong>。</li><li>支持行级锁的数据库，如 InnoDB 会在访问行的时候加锁。<strong>使用索引可以减少访问的行数，从而减少锁的竞争，提高并发</strong>。</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能。</li></ul><p>❌ 索引的缺点：</p><ul><li><strong>创建和维护索引要耗费时间</strong>，这会随着数据量的增加而增加。</li><li><strong>索引需要占用额外的物理空间</strong>，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立组合索引那么需要的空间就会更大。</li><li><strong>写操作（<code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code>）时很可能需要更新索引，导致数据库的写操作性能降低</strong>。</li></ul><p>基于以上，可以归纳出索引的基本使用规则：</p><ul><li>索引不是越多越好，不要为所有列都创建索引</li><li>要尽量避免冗余和重复索引</li><li>要考虑删除未使用的索引</li><li>尽量的扩展索引，不要新建索引</li><li>频繁作为 WHERE 过滤条件的列应该考虑添加索引</li></ul><h3 id="何时适用索引-何时不适用索引" tabindex="-1"><a class="header-anchor" href="#何时适用索引-何时不适用索引" aria-hidden="true">#</a> 何时适用索引？何时不适用索引？</h3><p>✔️️️️ 什么情况<strong>适用</strong>索引？</p><ul><li><strong>字段的数值有唯一性的限制</strong>，如用户名。</li><li><strong>频繁作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段，尤其在数据表大的情况下</strong>。</li><li><strong>频繁用于 <code>GROUP BY</code> 或 <code>ORDER BY</code> 的字段</strong>。将该字段作为索引，查询时就无需再排序了，因为 B+ 树本身就是按序存储的。</li><li><strong>DISTINCT 字段需要创建索引</strong>。</li></ul><p>❌ 什么情况<strong>不适用</strong>索引？</p><ul><li><strong>频繁写操作</strong>（ <code>INSERT</code>/<code>UPDATE</code>/<code>DELETE</code> ），也就意味着需要更新索引。</li><li><strong>很少作为 <code>WHERE</code> 条件或 <code>JOIN</code> 条件的字段</strong>，也就意味着索引会经常无法命中，没有意义，还增加空间开销。</li><li><strong>非常小的表</strong>，对于非常小的表，大部分情况下简单的全表扫描更高效。</li><li><strong>特大型的表</strong>，建立和使用索引的代价将随之增长。可以考虑使用分区技术或 Nosql。</li></ul><h3 id="索引有哪些常见数据结构" tabindex="-1"><a class="header-anchor" href="#索引有哪些常见数据结构" aria-hidden="true">#</a> 索引有哪些常见数据结构？</h3><p>在 Mysql 中，<strong>索引是在存储引擎层而不是服务器层实现的</strong>，所以，并没有统一的索引标准。不同存储引擎的索引的数据结构也不相同。下面是 Mysql 常用存储引擎对一些主要索引数据结构的支持：</p><table><thead><tr><th>索引数据结构/存储引擎</th><th>InnoDB 引擎</th><th>MyISAM 引擎</th><th>Memory 引擎</th></tr></thead><tbody><tr><td><strong>B+ 树索引</strong></td><td>✔️️️️️️️</td><td>✔️️️️️️️</td><td>✔️️️️️️️</td></tr><tr><td><strong>Hash 索引</strong></td><td>❌</td><td>❌</td><td>✔️️️️️️️</td></tr><tr><td><strong>Full Text 索引</strong></td><td>✔️️️️️️️</td><td>✔️️️️️️️</td><td>❌</td></tr></tbody></table><p>Mysql 索引的常见数据结构：</p><ul><li><strong>哈希索引</strong><ul><li>因为索引数据结构紧凑，所以<strong>查询速度非常快</strong>。</li><li><strong>只支持等值比较查询</strong> - 包括 <code>=</code>、<code>IN()</code>、<code>&lt;=&gt;</code>；<strong>不支持任何范围查询</strong>，如 <code>WHERE price &gt; 100</code>。</li><li><strong>无法用于排序</strong> - 因为哈希索引数据不是按照索引值顺序存储的。</li><li><strong>不支持部分索引匹配查找</strong> - 因为哈希索引时使用索引列的全部内容来进行哈希计算的。如，在数据列 (A,B) 上建立哈希索引，如果查询只有数据列 A，无法使用该索引。</li><li><strong>不能用索引中的值来避免读取行</strong> - 因为哈希索引只包含哈希值和行指针，不存储字段，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能影响不大。</li><li>哈希索引有<strong>可能出现哈希冲突</strong><ul><li>出现哈希冲突时，必须遍历链表中所有的行指针，逐行比较，直到找到符合条件的行。</li><li>如果哈希冲突多的话，维护索引的代价会很高。</li></ul></li></ul></li><li>B 树索引 <ul><li>适用于<strong>全键值查找</strong>、<strong>键值范围查找</strong>和<strong>键前缀查找</strong>，其中键前缀查找只适用于最左前缀查找。</li><li>所有的关键字（可以理解为数据）都存储在叶子节点，非叶子节点并不存储真正的数据，所有记录节点都是按键值大小顺序存放在同一层叶子节点上。</li><li>所有的叶子节点由指针连接。</li></ul></li></ul><h3 id="什么是聚簇索引-什么是非聚簇索引" tabindex="-1"><a class="header-anchor" href="#什么是聚簇索引-什么是非聚簇索引" aria-hidden="true">#</a> 什么是聚簇索引？什么是非聚簇索引？</h3><p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p><ul><li>主键索引又被称为**“聚簇索引（clustered index）”，其叶子节点存的是整行数据**。 <ul><li>聚簇表示数据行和相邻的键值紧凑地存储在一起，因为数据紧凑，所以访问快。</li><li>因为无法同时把数据行存放在两个不同的地方，所以<strong>一个表只能有一个聚簇索引</strong>。</li><li>InnoDB 的聚簇索引实际是在同一个结构中保存了 B 树的索引和数据行。</li></ul></li><li>非主键索引又被称为**“二级索引（secondary index）”，其叶子节点存的是主键的值**。数据存储在一个位置，索引存储在另一个位置，索引中包含指向数据存储位置的指针。可以有多个，小于 249 个。</li></ul><h3 id="聚簇索引和非聚簇索引的查询有什么区别" tabindex="-1"><a class="header-anchor" href="#聚簇索引和非聚簇索引的查询有什么区别" aria-hidden="true">#</a> 聚簇索引和非聚簇索引的查询有什么区别</h3><ul><li>如果语句是 <code>select * from T where ID=500</code>，即聚簇索引查询方式，则只需要搜索主键索引树；</li><li>如果语句是 <code>select * from T where k=5</code>，即非聚簇索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为<strong>回表</strong>。</li></ul><p>也就是说，<strong>基于非聚簇索引的查询需要多扫描一棵索引树</strong>。因此，我们在应用中应该尽量使用主键查询。</p><p><strong>显然，主键长度越小，非聚簇索引的叶子节点就越小，非聚簇索引占用的空间也就越小。</strong></p><h3 id="为什么-innodb-选择-b-树作为索引的数据结构" tabindex="-1"><a class="header-anchor" href="#为什么-innodb-选择-b-树作为索引的数据结构" aria-hidden="true">#</a> 为什么 InnoDB 选择 B+ 树作为索引的数据结构</h3><ul><li>B+ 树 vs B 树 <ul><li>B+ 树只在叶子节点存储数据，而 B 树的非叶子节点也要存储数据，所以 B+ 树的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点。</li><li>另外，B+ 树叶子节点采用的是双链表连接，适合 MySQL 中常见的基于范围的顺序查找，而 B 树无法做到这一点。</li></ul></li><li>B+树 vs 二叉树 <ul><li>对于有 N 个叶子节点的 B+ 树，其搜索复杂度为 <code>O(logdN)</code>，其中 d 表示节点允许的最大子节点个数为 d 个。</li><li>在实际的应用当中， d 值是大于 100 的，这样就保证了，即使数据达到千万级别时，B+ 树的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 3~4 次的磁盘 I/O 操作就能查询到目标数据。</li><li>而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着其搜索复杂度为 <code>O(logN)</code>，这已经比 B+ 树高出不少，因此二叉树检索到目标数据所经历的磁盘 I/O 次数要更多。</li></ul></li><li>B+树 vs Hash <ul><li>Hash 在做等值查询的时候效率贼快，搜索复杂度为 <code>O(1)</code>。</li><li>但是 Hash 表不适合做范围查询，它更适合做等值的查询，这也是 B+ 树索引要比 Hash 表索引有着更广泛的适用场景的原因。</li></ul></li></ul><h3 id="索引有哪些优化策略" tabindex="-1"><a class="header-anchor" href="#索引有哪些优化策略" aria-hidden="true">#</a> 索引有哪些优化策略？</h3><h4 id="索引基本原则" tabindex="-1"><a class="header-anchor" href="#索引基本原则" aria-hidden="true">#</a> 索引基本原则</h4><ul><li><strong>索引不是越多越好，不要为所有列都创建索引</strong>。要考虑到索引的维护代价、空间占用和查询时回表的代价。索引一定是按需创建的，并且要尽可能确保足够轻量。一旦创建了多字段的联合索引，我们要考虑尽可能利用索引本身完成数据查询，减少回表的成本。</li><li>要<strong>尽量避免冗余和重复索引</strong>。</li><li>要<strong>考虑删除未使用的索引</strong>。</li><li><strong>尽量的扩展索引，不要新建索引</strong>。</li><li><strong>频繁作为 <code>WHERE</code> 过滤条件的列应该考虑添加索引</strong>。</li></ul><h4 id="覆盖索引" tabindex="-1"><a class="header-anchor" href="#覆盖索引" aria-hidden="true">#</a> 覆盖索引</h4><p><strong>覆盖索引是指：索引上的信息足够满足查询请求，不需要回表查询数据</strong>。</p><p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段</strong>。</p><h4 id="最左前缀匹配原则" tabindex="-1"><a class="header-anchor" href="#最左前缀匹配原则" aria-hidden="true">#</a> 最左前缀匹配原则</h4><p><strong>这里的最左前缀，可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符</strong>。</p><p>如果是联合索引，那么 key 也由多个列组成，同时，索引只能用于查找 key 是否<strong>存在（相等）</strong>，遇到范围查询 (<code>&gt;</code>、<code>&lt;</code>、<code>BETWEEN</code>、<code>LIKE</code>) 就<strong>不能进一步匹配</strong>了，后续退化为线性查找。因此，<strong>列的排列顺序决定了可命中索引的列数</strong>。</p><p><strong>应该将选择性高的列或基数大的列优先排在多列索引最前列</strong>。<strong>“索引的选择性”是指不重复的索引值和记录总数的比值</strong>，选择性越高，查询效率越高。但有时，也需要考虑 <code>WHERE</code> 子句中的排序、分组和范围条件等因素，这些因素也会对查询性能造成较大影响。</p><h4 id="前缀索引" tabindex="-1"><a class="header-anchor" href="#前缀索引" aria-hidden="true">#</a> 前缀索引</h4><p><strong>“前缀索引”是指索引开始的部分字符</strong>。对于 <code>BLOB</code>/<code>TEXT</code>/<code>VARCHAR</code> 这种文本类型的列，必须使用前缀索引，因为数据库往往不允许索引这些列的完整长度。</p><p>前缀索引的优点是可以<strong>大大节约索引空间</strong>，从而<strong>提高索引效率</strong>。</p><p>前缀索引的缺点是<strong>会降低索引的区分度</strong>。此外，<strong><code>order by</code> 无法使用前缀索引，无法把前缀索引用作覆盖索引</strong>。</p><h4 id="独立索引" tabindex="-1"><a class="header-anchor" href="#独立索引" aria-hidden="true">#</a> 独立索引</h4><ul><li>索引列不能是表达式的一部分，也不能是函数的参数</li><li>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</li></ul><p>使用索引扫描来排序：ORDER BY 的字段作为索引，这样命中索引的查询结果，不需要额外排序</p><p>= 和 in 可以乱序：不需要考虑 =、IN 等的顺序，Mysql 会自动优化这些条件的顺序，以匹配尽可能多的索引列。</p><h3 id="哪些情况下-索引会失效" tabindex="-1"><a class="header-anchor" href="#哪些情况下-索引会失效" aria-hidden="true">#</a> 哪些情况下，索引会失效？</h3><p>导致索引失效的情况有：</p><ul><li>对索引使用左或者左右模糊匹配</li><li>对索引使用函数或表达式</li><li>对索引隐式类型转换</li><li>联合索引不遵循最左匹配原则</li><li>WHERE 子句中的 OR</li></ul><h3 id="普通索引和唯一索引-应该怎么选择" tabindex="-1"><a class="header-anchor" href="#普通索引和唯一索引-应该怎么选择" aria-hidden="true">#</a> 普通索引和唯一索引，应该怎么选择？</h3><p>普通索引和唯一索引的<strong>查询性能相差微乎其微</strong>。</p><h3 id="为什么-mysql-单表不要超过-2000w-行" tabindex="-1"><a class="header-anchor" href="#为什么-mysql-单表不要超过-2000w-行" aria-hidden="true">#</a> 为什么 MySQL 单表不要超过 2000W 行</h3><h2 id="事务" tabindex="-1"><a class="header-anchor" href="#事务" aria-hidden="true">#</a> 事务</h2><h3 id="什么是事务-什么是-acid" tabindex="-1"><a class="header-anchor" href="#什么是事务-什么是-acid" aria-hidden="true">#</a> 什么是事务，什么是 ACID</h3><p><strong>“事务”指的是满足 ACID 特性的一组操作</strong>。事务内的 SQL 语句，要么全执行成功，要么全执行失败。可以通过 <code>Commit</code> 提交一个事务，也可以使用 <code>Rollback</code> 进行回滚。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226555.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>ACID 是数据库事务正确执行的四个基本要素。</p><ul><li><strong>原子性（Atomicity）</strong><ul><li>事务被视为不可分割的最小单元，事务中的所有操作要么全部提交成功，要么全部失败回滚。</li><li>回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。</li></ul></li><li><strong>一致性（Consistency）</strong><ul><li>数据库在事务执行前后都保持一致性状态。</li><li>在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li></ul></li><li><strong>隔离性（Isolation）</strong><ul><li>一个事务所做的修改在最终提交以前，对其它事务是不可见的。</li></ul></li><li><strong>持久性（Durability）</strong><ul><li>一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。</li><li>可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。</li></ul></li></ul><p>一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性。</p><h3 id="事务存在哪些并发修改问题" tabindex="-1"><a class="header-anchor" href="#事务存在哪些并发修改问题" aria-hidden="true">#</a> 事务存在哪些并发修改问题</h3><p>事务中存在的并发修改问题有：</p><ul><li>丢失修改</li><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><p><strong>“丢失修改”是指一个事务的更新操作被另外一个事务的更新操作替换</strong>。</p><p>如下图所示，T<sub>1</sub> 和 T<sub>2</sub> 两个事务对同一个数据进行修改，T<sub>1</sub> 先修改，T<sub>2</sub> 随后修改，T<sub>2</sub> 的修改覆盖了 T<sub>1</sub> 的修改。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226657.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“脏读（dirty read）”是指当前事务可以读取其他事务未提交的数据</strong>。</p><p>如下图所示，T<sub>1</sub> 修改一个数据，T<sub>2</sub> 随后读取这个数据。如果 T<sub>1</sub> 撤销了这次修改，那么 T<sub>2</sub> 读取的数据是脏数据。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092226116.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“不可重复读（non-repeatable read）”是指一个事务内多次读取同一数据，过程中，该数据被其他事务所修改，导致当前事务多次读取的数据可能不一致</strong>。</p><p>如下图所示，T<sub>2</sub> 读取一个数据，T<sub>1</sub> 对该数据做了修改。如果 T<sub>2</sub> 再次读取这个数据，此时读取的结果和第一次读取的结果不同。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092227863.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>“幻读（phantom read）”是指一个事务内多次读取同一范围的数据，过程中，其他事务在该数据范围新增了数据，导致当前事务未发现新增数据</strong>。</p><p>事务 T<sub>1</sub> 读取某个范围内的记录时，事务 T<sub>2</sub> 在该范围内插入了新的记录，T<sub>1</sub> 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092227171.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="有哪些事务隔离级别-分别解决了什么问题" tabindex="-1"><a class="header-anchor" href="#有哪些事务隔离级别-分别解决了什么问题" aria-hidden="true">#</a> 有哪些事务隔离级别，分别解决了什么问题</h3><p>为了解决以上提到的并发修改问题，SQL 标准提出了四种“事务隔离级别”来应对这些问题。事务隔离级别等级越高，越能保证数据的一致性和完整性，但是执行效率也越低。因此，设置数据库的事务隔离级别时需要做一下权衡。</p><p>事务隔离级别从低到高分别是：</p><ul><li><strong>“读未提交（read uncommitted）”</strong> - 是指，<strong>事务中的修改，即使没有提交，对其它事务也是可见的</strong>。</li><li>**“读已提交（read committed）” ** - 是指，<strong>事务提交后，其他事务才能看到它的修改</strong>。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。 <ul><li><strong>读已提交解决了脏读的问题</strong>。</li><li>读已提交是大多数数据库的默认事务隔离级别，如 Oracle。</li></ul></li><li><strong>“可重复读（repeatable read）”</strong> - 是指：<strong>保证在同一个事务中多次读取同样数据的结果是一样的</strong>。 <ul><li><strong>可重复读解决了不可重复读问题</strong>。</li><li><strong>可重复读是 InnoDB 存储引擎的默认事务隔离级别</strong>。</li></ul></li><li><strong>“串行化（serializable ）”</strong> - 是指，<strong>强制事务串行执行</strong>，对于同一行记录，加读写锁，一旦出现锁冲突，必须等前面的事务释放锁。 <ul><li><strong>串行化解决了幻读问题</strong>。由于强制事务串行执行，自然避免了所有的并发问题。</li><li><strong>串行化策略会在读取的每一行数据上都加锁</strong>，这可能导致大量的超时和锁竞争。这对于高并发应用基本上是不可接受的，所以一般不会采用这个级别。</li></ul></li></ul><p>事务隔离级别对并发修改问题的解决情况：</p><table><thead><tr><th style="text-align:center;">隔离级别</th><th style="text-align:center;">丢失修改</th><th style="text-align:center;">脏读</th><th style="text-align:center;">不可重复读</th><th style="text-align:center;">幻读</th></tr></thead><tbody><tr><td style="text-align:center;">读未提交</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">读已提交</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">可重复读</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">可串行化</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td><td style="text-align:center;">✔️️️</td></tr></tbody></table><h3 id="各事务隔离级别是如何实现的" tabindex="-1"><a class="header-anchor" href="#各事务隔离级别是如何实现的" aria-hidden="true">#</a> 各事务隔离级别是如何实现的</h3><p>Mysql 中的事务功能是在存储引擎层实现的，<strong>并非所有存储引擎都支持事务功能</strong>。InnoDB 是 Mysql 的首先事务存储引擎。</p><p>四种隔离级别具体是如何实现的呢？</p><p>以 InnoDB 的事务实现来说明：</p><ul><li>对于“读未提交”隔离级别的事务来说，因为可以读到未提交事务修改的数据，所以直接读取最新的数据就好了；</li><li>对于“串行化”隔离级别的事务来说，通过加读写锁的方式来避免并行访问；</li><li>对于“读提交”和“可重复读”隔离级别的事务来说，它们都是通过 ReadView 来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。 <ul><li>“读提交”隔离级别是在“每个语句执行前”都会重新生成一个 ReadView</li><li>“可重复读”隔离级别是在“启动事务时”生成一个 ReadView，然后整个事务期间都在用这个 ReadView。</li></ul></li></ul><h3 id="什么是-mvcc" tabindex="-1"><a class="header-anchor" href="#什么是-mvcc" aria-hidden="true">#</a> 什么是 MVCC</h3><p><strong>MVCC 是 Multi Version Concurrency Control 的缩写，即“多版本并发控制”</strong>。MVCC 的设计目标是提高数据库的并发性，采用非阻塞的方式去处理读/写并发冲突，可以将其看成一种乐观锁。</p><p>不仅是 Mysql，包括 Oracle、PostgreSQL 等其他关系型数据库都实现了各自的 MVCC，实现机制没有统一标准。<strong>MVCC 是 InnoDB 存储引擎实现事务隔离级别的一种具体方式</strong>。其主要用于实现读已提交和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，要求很低，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。</p><h3 id="mvcc-的实现原理是什么" tabindex="-1"><a class="header-anchor" href="#mvcc-的实现原理是什么" aria-hidden="true">#</a> MVCC 的实现原理是什么</h3><p>MVCC 的实现原理，主要基于隐式字段、UndoLog、ReadView 来实现。</p><h4 id="隐式字段" tabindex="-1"><a class="header-anchor" href="#隐式字段" aria-hidden="true">#</a> 隐式字段</h4><p>InnoDB 存储引擎中，数据表的每行记录，除了用户显示定义的字段以外，还有几个数据库隐式定义的字段：</p><ul><li><code>row_id</code> - <strong>隐藏的自增 ID</strong>。如果数据表没有指定主键，InnoDB 会自动基于 <code>row_id</code> 产生一个聚簇索引。</li><li><code>trx_id</code> - <strong>最近修改的事务 ID</strong>。事务对某条聚簇索引记录进行改动时，就会把该事务的事务 id 记录在 trx_id 隐藏列里；</li><li><code>roll_pointer</code> - <strong>回滚指针</strong>，指向这条记录的上一个版本。</li></ul><h4 id="undolog" tabindex="-1"><a class="header-anchor" href="#undolog" aria-hidden="true">#</a> UndoLog</h4><p>MVCC 的多版本指的是多个版本的快照，快照存储在 UndoLog 中。该日志通过回滚指针 <code>roll_pointer</code> 把一个数据行的所有快照链接起来，构成一个<strong>版本链</strong>。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092231914.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="readview" tabindex="-1"><a class="header-anchor" href="#readview" aria-hidden="true">#</a> ReadView</h4><p><strong>ReadView 就是事务进行快照读时产生的读视图（快照）</strong>。</p><p>ReadView 有四个重要的字段：</p><ul><li><code>m_ids</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”的事务 ID 列表。注意：这是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li><code>min_trx_id</code> - 指的是在创建 ReadView 时，当前数据库中“活跃事务”中事务 id 最小的事务，也就是 <code>m_ids</code> 的最小值。</li><li><code>max_trx_id</code> - 这个并不是 m_ids 的最大值，而是指创建 ReadView 时当前数据库中应该给下一个事务分配的 ID 值，也就是全局事务中最大的事务 ID 值 + 1；</li><li><code>creator_trx_id</code> - 指的是创建该 ReadView 的事务的事务 ID。</li></ul><p>在创建 ReadView 后，我们可以将记录中的 trx_id 划分为三种情况：</p><ul><li>已提交事务</li><li>已启动但未提交的事务</li><li>未启动的事务</li></ul><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/202310092230178.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><blockquote><p>ReadView 如何判断版本链中哪个版本可见？</p></blockquote><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li><code>trx_id == creator_trx_id</code> - 表示 <code>trx_id</code> 版本记录由 ReadView 所代表的当前事务产生，当然可以访问。</li><li><code>trx_id &lt; min_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之前已提交的事务生成的，当前事务可以访问。</li><li><code>trx_id &gt;= max_trx_id</code> - 表示 <code>trx_id</code> 版本记录是在创建 ReadView 之后才启动的事务生成的，当前事务不可以访问。</li><li><code>min_trx_id &lt;= trx_id &lt; max_trx_id</code> - 需要判断 <code>trx_id</code> 是否在 <code>m_ids</code> 列表中 <ul><li>如果 <code>trx_id</code> 在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务依然活跃（未提交事务），当前事务不可以访问。</li><li>如果 <code>trx_id</code> 不在 <code>m_ids</code> 列表中，表示生成 <code>trx_id</code> 版本记录的事务已提交，当前事务可以访问。</li></ul></li></ul><p>这种通过“版本链”来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</p><h3 id="mvcc-实现了哪些隔离级别-如何实现的" tabindex="-1"><a class="header-anchor" href="#mvcc-实现了哪些隔离级别-如何实现的" aria-hidden="true">#</a> MVCC 实现了哪些隔离级别，如何实现的</h3><p>对于“读已提交”和“可重复读”隔离级别的事务来说，它们都是通过 MVCC 的 ReadView 机制来实现的，区别仅在于创建 ReadView 的时机不同。ReadView 可以理解为一个数据快照。</p><ul><li><strong>可重复读隔离级别只有在启动事务时才会创建 ReadView，然后整个事务期间都使用这个 ReadView</strong>。这样就保证了在事务期间读到的数据都是事务启动前的记录。</li><li><strong>读已提交隔离级别每次读取数据时都会创建一个 ReadView</strong>。这意味着，事务期间的多次读取同一条数据，前后读取的数据可能会出现不一致——因为，这期间可能有另外一个事务修改了该记录，并提交了事务。</li></ul><p>这两个隔离级别的实现是通过“事务的 ReadView 里的字段”和“记录中的两个隐藏列”的比对，来控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。</p><p>MySQL InnoDB 引擎的默认隔离级别虽然是“可重复读”，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 <code>SELECT</code> 语句），<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（<code>SELECT ... FOR UPDATE</code> 等语句），<strong>通过 Next-Key Lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 <code>SELECT ... FOR UPDATE</code> 语句的时候，会加上 Next-Key Lock，如果有其他事务在 Next-Key Lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好的避免了幻读问题。</li></ul><h2 id="锁" tabindex="-1"><a class="header-anchor" href="#锁" aria-hidden="true">#</a> 锁</h2><h3 id="mysql-中有哪些锁" tabindex="-1"><a class="header-anchor" href="#mysql-中有哪些锁" aria-hidden="true">#</a> Mysql 中有哪些锁</h3><p>为了解决并发访问题，Mysql 支持了很多种锁来实现不同程度的隔离性，以保证数据的安全性。</p><h4 id="独享锁和共享锁" tabindex="-1"><a class="header-anchor" href="#独享锁和共享锁" aria-hidden="true">#</a> 独享锁和共享锁</h4><p>InnoDB 实现标准行级锁定，根据是否独占资源，可以把锁分为两类：</p><ul><li><strong>独享锁（Exclusive）</strong>，简写为 X 锁，又称<strong>写锁</strong>。 <ul><li>独占锁允许持有该锁的事务更新或删除行。</li><li>使用方式：<code>SELECT ... FOR UPDATE;</code></li></ul></li><li><strong>共享锁（Shared）</strong>，简写为 S 锁，又称<strong>读锁</strong>。 <ul><li>共享锁允许持有该锁的事务读取一行。</li><li>使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li></ul></li></ul><p>为什么要引入读写锁机制？</p><p>实际上，读写锁是一种通用的锁机制，并非 Mysql 的专利。在很多软件领域，都存在读写锁机制。</p><p>因为读操作本身是线程安全的，而一般业务往往又是读多写少的情况。因此，如果对读操作进行互斥，是不必要的，并且会大大降低并发访问效率。正式为了应对这种问题，产生了读写锁机制。</p><p>读写锁的特点是：<strong>读读不互斥</strong>、<strong>读写互斥</strong>、<strong>写写互斥</strong>。简言之：<strong>只要存在写锁，其他事务就不能做任何操作</strong>。</p><blockquote><p>注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。</p></blockquote><h4 id="悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁和乐观锁" aria-hidden="true">#</a> 悲观锁和乐观锁</h4><p>基于加锁方式分类，Mysql 可以分为悲观锁和乐观锁。</p><ul><li><strong>悲观锁</strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 <ul><li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li><li>实现方式：<strong>使用数据库中的锁机制</strong>。</li></ul></li><li><strong>乐观锁</strong> - 假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。只在更新的时候，判断一下在此期间是否有其他线程更新该数据。 <ul><li>实现方式：<strong>更新数据时，先使用版本号机制或 CAS 算法检查数据是否被修改</strong>。</li></ul></li></ul><p>为什么要引入乐观锁？</p><p>乐观锁也是一种通用的锁机制，在很多软件领域，都存在乐观锁机制。</p><p><strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。那么，为了提高并发度，能不能尽量不加锁呢？</p><p>乐观锁，顾名思义，就是假设最好的情况——每次访问数据时，都假设数据不会被其他线程修改，不必加锁。虽然不加锁，但不意味着什么都不做，而是在更新的时候，判断一下在此期间是否有其他线程更新该数据。乐观锁最常见的实现方式，是使用版本号机制或 CAS 算法（Compare And Swap）去实现。</p><p>乐观锁的<strong>优点</strong>是：减少锁竞争，提高并发度。</p><p>乐观锁的<strong>缺点</strong>是：</p><ul><li><strong>存在 ABA 问题</strong>。所谓的 ABA 问题是指在并发编程中，如果一个变量初次读取的时候是 A 值，它的值被改成了 B，然后又其他线程把 B 值改成了 A，而另一个早期线程在对比值时会误以为此值没有发生改变，但其实已经发生变化了</li><li>如果乐观锁所检查的数据存在大量锁竞争，会由于<strong>不断循环重试，产生大量的 CPU 开销</strong>。</li></ul><h4 id="全局锁、表级锁、行级锁" tabindex="-1"><a class="header-anchor" href="#全局锁、表级锁、行级锁" aria-hidden="true">#</a> 全局锁、表级锁、行级锁</h4><p>前文提到了，<strong>锁，意味着互斥，意味着阻塞。在高并发场景下，锁越多，阻塞越多，势必会拉低并发性能</strong>。在不得不加锁的情况下，显然，加锁的范围越小，锁竞争的发生频率就越小，系统的并发程度就越高。但是，加锁也需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销，<strong>锁粒度越小，系统的锁操作开销就越大</strong>。因此，在选择锁粒度时，也需要在锁开销和并发程度之间做一个权衡。</p><p>根据加锁的范围，MySQL 的锁大致可以分为：</p><ul><li><strong>全局锁</strong> - “全局锁”会锁定整个数据库。</li><li><strong>表级锁（table lock）</strong> - “表级锁”锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。表级锁有： <ul><li><strong>表锁</strong></li><li><strong>元数据锁（MDL）</strong></li><li><strong>意向锁（Intention Lock）</strong></li><li><strong>自增锁（AUTO-INC）</strong></li></ul></li><li><strong>行级锁（row lock）</strong> - “行级锁”锁定指定的行记录。这样其它线程还是可以对同一个表中的其它行记录进行操作。行级锁有： <ul><li><strong>记录锁（Record Lock）</strong></li><li><strong>间隙锁（Gap Lock）</strong></li><li><strong>临键锁（Next-Key Lock）</strong></li><li><strong>插入意向锁</strong></li></ul></li></ul><p>以上各种加锁粒度，在不同存储引擎中的支持情况并不相同。如：InnoDB 支持全局锁、表级锁、行级锁；而 MyISAM 只支持全局锁、表级锁。</p><h3 id="死锁是如何产生的" tabindex="-1"><a class="header-anchor" href="#死锁是如何产生的" aria-hidden="true">#</a> 死锁是如何产生的</h3><p><strong>“死锁”是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象</strong>。</p><p>产生死锁的场景：</p><ul><li>当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。</li><li>多个事务同时锁定同一个资源时，也会产生死锁。</li></ul><h3 id="如何避免死锁" tabindex="-1"><a class="header-anchor" href="#如何避免死锁" aria-hidden="true">#</a> 如何避免死锁</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。由此可知，要想避免死锁，就要从这几个必要条件上去着手：</p><ul><li>更新表时，<strong>尽量使用主键更新</strong>，减少冲突；</li><li><strong>避免长事务</strong>，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；</li><li><strong>设置合理的锁等待超时参数</strong>，我们可以通过 <code>innodb_lock_wait_timeout</code> 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。</li><li>在编程中<strong>尽量按照固定的顺序来处理数据库记录</strong>，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；</li><li>在允许幻读和不可重复读的情况下，尽量使用读已提交事务隔离级别，可以避免 Gap Lock 导致的死锁问题；</li><li>还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。</li></ul><h3 id="如何解决死锁" tabindex="-1"><a class="header-anchor" href="#如何解决死锁" aria-hidden="true">#</a> 如何解决死锁</h3><p>当出现死锁以后，有两种策略：</p><ul><li><strong>设置事务等待锁的超时时间</strong>。这个超时时间可以通过参数 <code>innodb_lock_wait_timeout</code> 来设置。</li><li><strong>开启死锁检测</strong>，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 <code>on</code>，表示开启这个逻辑。</li></ul><p>在 InnoDB 中，<code>innodb_lock_wait_timeout</code> 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。但是，我直接把这个时间设置成一个很小的值，比如 1s，也是不可取的。当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p><p>所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 <code>innodb_deadlock_detect</code> 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：<strong>将持有最少行级排它锁的事务进行回滚</strong>。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。</p><h2 id="ha" tabindex="-1"><a class="header-anchor" href="#ha" aria-hidden="true">#</a> HA</h2><h2 id="优化" tabindex="-1"><a class="header-anchor" href="#优化" aria-hidden="true">#</a> 优化</h2><h3 id="哪种-count-性能最好" tabindex="-1"><a class="header-anchor" href="#哪种-count-性能最好" aria-hidden="true">#</a> 哪种 COUNT 性能最好</h3><blockquote><p>先说结论：按照效率排序的话，<code>COUNT(字段)</code> &lt; <code>COUNT(主键 id)</code> &lt; <code>COUNT(1)</code> ≈ <code>COUNT(*)</code>。<strong>推荐采用 <code>COUNT(*)</code></strong> 。</p></blockquote><ul><li><p><strong>对于 <code>COUNT(主键 id)</code> 来说</strong>，InnoDB 引擎会遍历整张表，把每一行的 id 值都取出来，返回给 server 层。server 层拿到 id 后，判断是不可能为空的，就按行累加。</p></li><li><p><strong>对于 <code>COUNT(1)</code> 来说</strong>，InnoDB 引擎遍历整张表，但不取值。server 层对于返回的每一行，放一个数字“1”进去，判断是不可能为空的，按行累加。</p></li><li><p>单看这两个用法的差别的话，你能对比出来，<code>COUNT(1)</code> 执行得要比 <code>COUNT(主键 id)</code> 快。因为从引擎返回 id 会涉及到解析数据行，以及拷贝字段值的操作。</p></li><li><p><strong>对于 <code>COUNT(字段)</code> 来说</strong>：</p><ul><li>如果这个“字段”是定义为 <code>not null</code> 的话，一行行地从记录里面读出这个字段，判断不能为 <code>null</code>，按行累加；</li><li>如果这个“字段”定义允许为 <code>null</code>，那么执行的时候，判断到有可能是 <code>null</code>，还要把值取出来再判断一下，不是 <code>null</code> 才累加。</li><li>也就是前面的第一条原则，server 层要什么字段，InnoDB 就返回什么字段。</li></ul></li></ul><p><strong>但是 <code>COUNT(*)</code> 是例外</strong>，并不会把全部字段取出来，而是专门做了优化，不取值。<code>COUNT(*)</code> 肯定不是 <code>null</code>，按行累加。</p><p>不同的 MySQL 引擎中，<code>COUNT(*)</code> 有不同的实现方式：</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 <code>COUNT(*)</code> 的时候会直接返回这个数，效率很高；</li><li>而 InnoDB 引擎就麻烦了，它执行 <code>COUNT(*)</code> 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li></ul><blockquote><p>为什么 InnoDB 不跟 MyISAM 一样，也维护一个计数器？</p></blockquote><p>因为即使是在同一个时刻的多个查询，由于多版本并发控制（MVCC）的原因，InnoDB 表“应该返回多少行”也是不确定的。</p><p>InnoDB 是索引组织表，主键索引树的叶子节点是数据，而普通索引树的叶子节点是主键值。所以，普通索引树比主键索引树小很多。对于 <code>COUNT(*)</code> 这样的操作，遍历哪个索引树得到的结果逻辑上都是一样的。因此，MySQL 优化器会找到最小的那棵树来遍历。</p><ul><li>MyISAM 表虽然 <code>COUNT(*)</code> 很快，但是不支持事务；</li><li><code>show table status</code> 命令虽然返回很快，但是不准确；</li><li>InnoDB 表直接 <code>COUNT(*)</code> 会遍历全表，虽然结果准确，但会导致性能问题。</li></ul><blockquote><p>如何优化查询计数？</p></blockquote><p>可以使用 Redis 保存计数，但存在丢失更新一集数据不一致问题。</p><p>可以使用数据库其他表保存计数，但要用事务进行控制，增/删数据时，同步改变计数。</p><h3 id="exists-和-in-有什么区别" tabindex="-1"><a class="header-anchor" href="#exists-和-in-有什么区别" aria-hidden="true">#</a> EXISTS 和 IN 有什么区别</h3><ul><li><code>EXISTS</code> - 先对外表进行循环查询，再将查询结果放入 <code>EXISTS</code> 的子查询中进行条件比较，确定外层查询数据是否保留；</li><li><code>IN</code> - 先查询内表，将内表的查询结果作为条件，提供给外表查询语句进行比较；</li></ul><p>索引是个前提，其实选择与否还是要看表的大小。你可以将选择的标准理解为小表驱动大表。在这种方式下效率是最高的。</p><p>比如下面这样：</p><div class="language-mysql line-numbers-mode" data-ext="mysql"><pre class="language-mysql"><code> SELECT * FROM A WHERE cc IN (SELECT cc FROM B)
 SELECT * FROM A WHERE EXISTS (SELECT cc FROM B WHERE B.cc=A.cc)
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当 A 小于 B 时，用 <code>EXISTS</code>。因为 <code>EXISTS</code> 的实现，相当于外表循环，实现的逻辑类似于：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token keyword">for</span> i <span class="token operator">in</span> A
     <span class="token keyword">for</span> j <span class="token operator">in</span> B
         <span class="token keyword">if</span> j<span class="token punctuation">.</span>cc <span class="token operator">=</span><span class="token operator">=</span> i<span class="token punctuation">.</span>cc <span class="token keyword">then</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当 B 小于 A 时用 <code>IN</code>，因为实现的逻辑类似于：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code> <span class="token keyword">for</span> i <span class="token operator">in</span> B
     <span class="token keyword">for</span> j <span class="token operator">in</span> A
         <span class="token keyword">if</span> j<span class="token punctuation">.</span>cc <span class="token operator">=</span><span class="token operator">=</span> i<span class="token punctuation">.</span>cc <span class="token keyword">then</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>哪个表小就用哪个表来驱动，A 表小就用 <code>EXISTS</code>，B 表小就用 <code>IN</code>；如果两个表大小相当，则使用 <code>EXISTS</code> 和 <code>IN</code> 的区别不大。</p><h3 id="union-和-union-all-有什么区别" tabindex="-1"><a class="header-anchor" href="#union-和-union-all-有什么区别" aria-hidden="true">#</a> UNION 和 UNION ALL 有什么区别</h3><p><code>UNION</code> 和 <code>UNION ALL</code> 都是将两个结果集合并为一个，<strong>两个要联合的 SQL 语句字段个数必须一样，而且字段类型要“相容”（一致）</strong>。</p><ul><li><code>UNION</code> 需要进行去重扫描，因此消息较低；而 <code>UNION ALL</code> 不会进行去重。</li><li><code>UNION</code> 会按照字段的顺序进行排序；而 <code>UNION ALL</code> 只是简单的将两个结果合并就返回。</li></ul><h3 id="join-有哪些类型" tabindex="-1"><a class="header-anchor" href="#join-有哪些类型" aria-hidden="true">#</a> JOIN 有哪些类型</h3><p>连接用于连接多个表，使用 <code>JOIN</code> 关键字，并且条件语句使用 <code>ON</code> 而不是 <code>WHERE</code>。</p><p><code>JOIN</code> 可以分为两大类：内连接和外连接。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/database/mysql/sql-join.png" alt="SQL JOIN" tabindex="0" loading="lazy"><figcaption>SQL JOIN</figcaption></figure><h4 id="内连接-inner-join" tabindex="-1"><a class="header-anchor" href="#内连接-inner-join" aria-hidden="true">#</a> 内连接（INNER JOIN）</h4><p>内连接又称等值连接，<strong>使用 <code>INNER JOIN</code> 关键字</strong>。在没有条件语句的情况下<strong>返回笛卡尔积</strong>。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> vend_name<span class="token punctuation">,</span> prod_name<span class="token punctuation">,</span> prod_price
<span class="token keyword">FROM</span> vendors <span class="token keyword">INNER</span> <span class="token keyword">JOIN</span> products
<span class="token keyword">ON</span> vendors<span class="token punctuation">.</span>vend_id <span class="token operator">=</span> products<span class="token punctuation">.</span>vend_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自连接（<code>=</code>）</p><p>自连接可以看成内连接的一种，只是<strong>连接的表是自身</strong>而已。<strong>自然连接是把同名列通过 <code>=</code> 连接起来</strong>的，同名列可以有多个。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> c1<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> c1<span class="token punctuation">.</span>cust_name<span class="token punctuation">,</span> c1<span class="token punctuation">.</span>cust_contact
<span class="token keyword">FROM</span> customers c1<span class="token punctuation">,</span> customers c2
<span class="token keyword">WHERE</span> c1<span class="token punctuation">.</span>cust_name <span class="token operator">=</span> c2<span class="token punctuation">.</span>cust_name
<span class="token operator">AND</span> c2<span class="token punctuation">.</span>cust_contact <span class="token operator">=</span> <span class="token string">&#39;Jim Jones&#39;</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>自然连接（<code>NATURAL JOIN</code>）</p><p>内连接提供连接的列，而自然连接<strong>自动连接所有同名列</strong>。自然连接使用 <code>NATURAL JOIN</code> 关键字。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> <span class="token operator">*</span>
<span class="token keyword">FROM</span> Products
<span class="token keyword">NATURAL</span> <span class="token keyword">JOIN</span> Customers<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="外连接-outer-join" tabindex="-1"><a class="header-anchor" href="#外连接-outer-join" aria-hidden="true">#</a> 外连接（<code>OUTER JOIN</code>）</h4><p>外连接返回一个表中的所有行，并且仅返回来自此表中满足连接条件的那些行，即两个表中的列是相等的。外连接分为左外连接、右外连接、全外连接（Mysql 不支持）。</p><p>左连接（<code>LEFT JOIN</code>）</p><p>左外连接就是保留左表没有关联的行。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num
<span class="token keyword">FROM</span> customers <span class="token keyword">LEFT</span> <span class="token keyword">JOIN</span> orders
<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>右连接（<code>RIGHT JOIN</code>）</p><p>右外连接就是保留右表没有关联的行。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">SELECT</span> customers<span class="token punctuation">.</span>cust_id<span class="token punctuation">,</span> orders<span class="token punctuation">.</span>order_num
<span class="token keyword">FROM</span> customers <span class="token keyword">RIGHT</span> <span class="token keyword">JOIN</span> orders
<span class="token keyword">ON</span> customers<span class="token punctuation">.</span>cust_id <span class="token operator">=</span> orders<span class="token punctuation">.</span>cust_id<span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="为什么这些-sql-语句逻辑相同-性能却差异巨大" tabindex="-1"><a class="header-anchor" href="#为什么这些-sql-语句逻辑相同-性能却差异巨大" aria-hidden="true">#</a> 为什么这些 SQL 语句逻辑相同，性能却差异巨大？</h3><h4 id="函数操作会破坏索引有序性" tabindex="-1"><a class="header-anchor" href="#函数操作会破坏索引有序性" aria-hidden="true">#</a> 函数操作会破坏索引有序性</h4><p><strong>对索引字段做函数操作，可能会破坏索引值的有序性，因此优化器就决定放弃走树搜索功能。</strong></p><p>示例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>tradelog<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>operator<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>t_modified<span class="token punctuation">\`</span></span> <span class="token keyword">datetime</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>t_modified<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>t_modified<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8mb4<span class="token punctuation">;</span>

<span class="token keyword">select</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tradelog <span class="token keyword">where</span> <span class="token keyword">month</span><span class="token punctuation">(</span>t_modified<span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">7</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>由于在 t_modified 字段加了 month() 函数操作，导致了全索引扫描。为了能够用上索引的快速定位能力，我们就要把 SQL 语句改成基于字段本身的范围查询。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">COUNT</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">from</span> tradelog <span class="token keyword">where</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>t_modified <span class="token operator">&gt;=</span> <span class="token string">&#39;2016-7-1&#39;</span> <span class="token operator">and</span> t_modified<span class="token operator">&lt;</span><span class="token string">&#39;2016-8-1&#39;</span><span class="token punctuation">)</span> <span class="token operator">or</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>t_modified <span class="token operator">&gt;=</span> <span class="token string">&#39;2017-7-1&#39;</span> <span class="token operator">and</span> t_modified<span class="token operator">&lt;</span><span class="token string">&#39;2017-8-1&#39;</span><span class="token punctuation">)</span> <span class="token operator">or</span>
    <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>t_modified <span class="token operator">&gt;=</span> <span class="token string">&#39;2018-7-1&#39;</span> <span class="token operator">and</span> t_modified<span class="token operator">&lt;</span><span class="token string">&#39;2018-8-1&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="隐式转换" tabindex="-1"><a class="header-anchor" href="#隐式转换" aria-hidden="true">#</a> 隐式转换</h4><p>下面两个 SQL 的执行流程相同：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tradelog <span class="token keyword">where</span> tradeid<span class="token operator">=</span><span class="token number">110717</span><span class="token punctuation">;</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> tradelog <span class="token keyword">where</span> CAST<span class="token punctuation">(</span>tradid <span class="token keyword">AS</span> signed <span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">110717</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>交易编号 tradeid 这个字段上，本来就有索引，但是 explain 的结果却显示，这条语句需要走全表扫描。这是由于这条语句隐式增加了转换函数，而对索引字段做函数操作，优化器会放弃走树搜索功能。</p><h4 id="隐式字符编码转换" tabindex="-1"><a class="header-anchor" href="#隐式字符编码转换" aria-hidden="true">#</a> 隐式字符编码转换</h4><p>示例：</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">\`</span>trade_detail<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span>
  <span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>
  <span class="token identifier"><span class="token punctuation">\`</span>trade_step<span class="token punctuation">\`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token comment">/* 操作步骤 */</span>
  <span class="token identifier"><span class="token punctuation">\`</span>step_info<span class="token punctuation">\`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">32</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span> <span class="token comment">/* 步骤信息 */</span>
  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>id<span class="token punctuation">\`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">\`</span>tradeid<span class="token punctuation">\`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> tradelog <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaaa&#39;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tradelog <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaab&#39;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> tradelog <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaac&#39;</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaaa&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;add&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaaa&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;update&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaaa&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;commit&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaab&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;add&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaab&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;update&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaab&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;update again&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaab&#39;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;commit&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaac&#39;</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">&#39;add&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaac&#39;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">&#39;update&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaac&#39;</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">&#39;update again&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">insert</span> <span class="token keyword">into</span> trade_detail <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token string">&#39;aaaaaaac&#39;</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">&#39;commit&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">SELECT</span> d<span class="token punctuation">.</span><span class="token operator">*</span>
<span class="token keyword">FROM</span> tradelog l<span class="token punctuation">,</span> trade_detail d
<span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>tradeid <span class="token operator">=</span> l<span class="token punctuation">.</span>tradeid <span class="token operator">AND</span> l<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment"># 等价于</span>
<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> trade_detail  <span class="token keyword">where</span> <span class="token keyword">CONVERT</span><span class="token punctuation">(</span>traideid <span class="token keyword">USING</span> utf8mb4<span class="token punctuation">)</span><span class="token operator">=</span>$L2<span class="token punctuation">.</span>tradeid<span class="token punctuation">.</span><span class="token keyword">value</span><span class="token punctuation">;</span>

<span class="token comment"># 不需要做字符编码转换</span>
<span class="token keyword">EXPLAIN</span>
<span class="token keyword">SELECT</span> l<span class="token punctuation">.</span>operator
<span class="token keyword">FROM</span> tradelog l<span class="token punctuation">,</span> trade_detail d
<span class="token keyword">WHERE</span> d<span class="token punctuation">.</span>tradeid <span class="token operator">=</span> l<span class="token punctuation">.</span>tradeid <span class="token operator">AND</span> d<span class="token punctuation">.</span>id <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>字符集 utf8mb4 是 utf8 的超集，所以当这两个类型的字符串在做比较的时候，MySQL 内部的操作是，先把 utf8 字符串转成 utf8mb4 字符集，再做比较。</p><h3 id="为什么我只查一行的语句-也执行这么慢" tabindex="-1"><a class="header-anchor" href="#为什么我只查一行的语句-也执行这么慢" aria-hidden="true">#</a> 为什么我只查一行的语句，也执行这么慢？</h3><h4 id="查询长时间不返回" tabindex="-1"><a class="header-anchor" href="#查询长时间不返回" aria-hidden="true">#</a> 查询长时间不返回</h4><p>查询结果长时间不返回。</p><p>一般碰到这种情况的话，大概率是表被锁住了。接下来分析原因的时候，一般都是首先执行一下 show processlist 命令，看看当前语句处于什么状态。</p><p>使用 show processlist 命令查看 Waiting for table metadata lock 的示意图</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220801160916.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>出现<strong>这个状态表示的是，现在有一个线程正在表 t 上请求或者持有 MDL 写锁，把 select 语句堵住了。</strong></p><h3 id="mysql-有哪些-饮鸩止渴-提高性能的方法" tabindex="-1"><a class="header-anchor" href="#mysql-有哪些-饮鸩止渴-提高性能的方法" aria-hidden="true">#</a> MySQL 有哪些“饮鸩止渴”提高性能的方法？</h3><h4 id="短连接风暴" tabindex="-1"><a class="header-anchor" href="#短连接风暴" aria-hidden="true">#</a> 短连接风暴</h4><p>短连接模式就是连接到数据库后，执行很少的 SQL 语句就断开，下次需要的时候再重连。</p><ul><li>MySQL 建立连接的成本很高。 <ul><li>除了正常的网络连接三次握手外，还需要做登录权限判断和获得这个连接的数据读写权限。</li></ul></li><li>短连接模型存在一个风险：一旦数据库处理速度很慢，连接数就会暴涨。</li><li><strong><code>max_connections</code> 控制一个 MySQL 实例同时存在的连接数的上限</strong>。 <ul><li>超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。</li></ul></li></ul><h4 id="解决方法-1-先处理掉那些占着连接但是不工作的线程" tabindex="-1"><a class="header-anchor" href="#解决方法-1-先处理掉那些占着连接但是不工作的线程" aria-hidden="true">#</a> 解决方法 1：先处理掉那些占着连接但是不工作的线程</h4><ul><li><code>show processlist</code> 查看 <code>sleep</code> 的线程，然后干掉空闲的连接。注意：可能会误杀事务。</li><li>应该优先断开事务外空闲的连接。 <ul><li>通过查 <code>information_schema</code> 库的 <code>innodb_trx</code> 表判断是否处于事务中。</li></ul></li><li>再考虑断开事务内空闲太久的连接。</li></ul><h4 id="解决方法-2-减少连接过程的消耗" tabindex="-1"><a class="header-anchor" href="#解决方法-2-减少连接过程的消耗" aria-hidden="true">#</a> 解决方法 2：减少连接过程的消耗</h4><p>如果想短时间创建大量数据库连接，有一种做法是跳过权限验证。</p><p>跳过权限验证的方法是：重启数据库，并使用 <code>–skip-grant-tables</code> 参数启动。</p><p>注意：此方法风险极高，不建议使用。</p><h3 id="慢查询性能问题" tabindex="-1"><a class="header-anchor" href="#慢查询性能问题" aria-hidden="true">#</a> 慢查询性能问题</h3><p>一般有三种可能：</p><ol><li>索引没有设计好；</li><li>SQL 语句没写好；</li><li>MySQL 选错了索引。 <ul><li>可以通过 <code>force index</code> 强制使用某个索引</li></ul></li></ol><h3 id="qps-突增问题" tabindex="-1"><a class="header-anchor" href="#qps-突增问题" aria-hidden="true">#</a> QPS 突增问题</h3><p>有时候由于业务突然出现高峰，或者应用程序 bug，导致某个语句的 QPS 突然暴涨，也可能导致 MySQL 压力过大，影响服务。</p><p>应对方法：</p><ol><li>一种是由全新业务的 bug 导致的。假设你的 DB 运维是比较规范的，也就是说白名单是一个个加的。这种情况下，如果你能够确定业务方会下掉这个功能，只是时间上没那么快，那么就可以从数据库端直接把白名单去掉。</li><li>如果这个新功能使用的是单独的数据库用户，可以用管理员账号把这个用户删掉，然后断开现有连接。这样，这个新功能的连接不成功，由它引发的 QPS 就会变成 0。</li><li>如果这个新增的功能跟主体功能是部署在一起的，那么我们只能通过处理语句来限制。这时，我们可以使用上面提到的查询重写功能，把压力最大的 SQL 语句直接重写成&quot;select 1&quot;返回。 <ul><li>这个方法是用于止血的，但风险很高，不建议使用。</li></ul></li></ol><p>个人观点：以上方法都是基于 DBA 视角的处理方式。实际环境中，应该做好数据库 QPS、CPU 监控，如果发现请求量激增，快要达到瓶颈，可以先紧急弹性扩容，保障业务不损失。然后排查原因，是否是新业务设计不当导致、是否是大数据在也业务高峰期进行数据分析导致，等等。</p><h3 id="join-语句如何优化" tabindex="-1"><a class="header-anchor" href="#join-语句如何优化" aria-hidden="true">#</a> join 语句如何优化</h3><p><strong>大多数的数据都是按照主键递增顺序插入得到的，所以我们可以认为，如果按照主键的递增顺序查询的话，对磁盘的读比较接近顺序读，能够提升读性能。</strong></p><h4 id="mrr" tabindex="-1"><a class="header-anchor" href="#mrr" aria-hidden="true">#</a> MRR</h4><p>MRR 优化后的语句执行流程：</p><ol><li>根据索引 a，定位到满足条件的记录，将 id 值放入 read_rnd_buffer 中 ;</li><li>将 read_rnd_buffer 中的 id 进行递增排序；</li><li>排序后的 id 数组，依次到主键 id 索引中查记录，并作为结果返回。</li></ol><p>这里，read_rnd_buffer 的大小是由 read_rnd_buffer_size 参数控制的。如果步骤 1 中，read_rnd_buffer 放满了，就会先执行完步骤 2 和 3，然后清空 read_rnd_buffer。之后继续找索引 a 的下个记录，并继续循环。</p><p><strong>MRR 能够提升性能的核心</strong>在于，这条查询语句在索引 a 上做的是一个范围查询（也就是说，这是一个多值查询），可以得到足够多的主键 id。这样通过排序以后，再去主键索引查数据，才能体现出“顺序性”的优势。临时表在使用上有以下几个特点：</p><ol><li>建表语法是 create temporary table …。</li><li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li><li>临时表可以与普通表同名。</li><li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li><li>show tables 命令不显示临时表。</li></ol><h4 id="到底可不可以使用-join" tabindex="-1"><a class="header-anchor" href="#到底可不可以使用-join" aria-hidden="true">#</a> 到底可不可以使用 join</h4><ol><li>如果可以使用被驱动表的索引，join 语句还是有其优势的；</li><li>不能使用被驱动表的索引，只能使用 Block Nested-Loop Join 算法，这样的语句就尽量不要使用；</li><li>在使用 join 的时候，应该让小表做驱动表。</li></ol><h3 id="我查了这么多数据会不会把数据库内存打爆" tabindex="-1"><a class="header-anchor" href="#我查了这么多数据会不会把数据库内存打爆" aria-hidden="true">#</a> 我查了这么多数据会不会把数据库内存打爆</h3><h4 id="全表扫描对-server-层的影响" tabindex="-1"><a class="header-anchor" href="#全表扫描对-server-层的影响" aria-hidden="true">#</a> 全表扫描对 server 层的影响</h4><p><strong>MySQL 是“边读边发的”</strong></p><p>InnoDB 的数据是保存在主键索引上的，所以全表扫描实际上是直接扫描表 t 的主键索引。这条查询语句由于没有其他的判断条件，所以查到的每一行都可以直接放到结果集里面，然后返回给客户端。</p><p>查询的结果是分段发给客户端的，因此扫描全表，查询返回大量的数据，并不会把内存打爆。</p><h4 id="全表扫描对-innodb-的影响" tabindex="-1"><a class="header-anchor" href="#全表扫描对-innodb-的影响" aria-hidden="true">#</a> 全表扫描对 InnoDB 的影响</h4><p>对于 InnoDB 引擎内部，由于有淘汰策略，大查询也不会导致内存暴涨。并且，由于 InnoDB 对 LRU 算法做了改进，冷数据的全表扫描，对 Buffer Pool 的影响也能做到可控。</p><h2 id="其他" tabindex="-1"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h2><h3 id="为什么临时表可以重名" tabindex="-1"><a class="header-anchor" href="#为什么临时表可以重名" aria-hidden="true">#</a> 为什么临时表可以重名</h3><p>临时表在使用上有以下几个特点：</p><ol><li>建表语法是 create temporary table …。</li><li>一个临时表只能被创建它的 session 访问，对其他线程不可见。所以，图中 session A 创建的临时表 t，对于 session B 就是不可见的。</li><li>临时表可以与普通表同名。</li><li>session A 内有同名的临时表和普通表的时候，show create 语句，以及增删改查语句访问的是临时表。</li><li>show tables 命令不显示临时表。</li></ol><p><strong>临时表特别适合 join 优化这种场景</strong>，原因是：</p><ol><li>不同 session 的临时表是可以重名的，如果有多个 session 同时执行 join 优化，不需要担心表名重复导致建表失败的问题。</li><li>不需要担心数据删除问题。如果使用普通表，在流程执行过程中客户端发生了异常断开，或者数据库发生异常重启，还需要专门来清理中间过程中生成的数据表。而临时表由于会自动回收，所以不需要这个额外的操作。</li></ol><h4 id="临时表的应用" tabindex="-1"><a class="header-anchor" href="#临时表的应用" aria-hidden="true">#</a> 临时表的应用</h4><p>由于不用担心线程之间的重名冲突，临时表经常会被用在复杂查询的优化过程中。其中，分库分表系统的跨库查询就是一个典型的使用场景。</p><p>分库分表两种实现思路：</p><p>**第一种思路是，**在 proxy 层的进程代码中实现排序。</p><p>这种方式的优势是处理速度快，拿到分库的数据以后，直接在内存中参与计算。不过，这个方案的缺点也比较明显：</p><ol><li>需要的开发工作量比较大。我们举例的这条语句还算是比较简单的，如果涉及到复杂的操作，比如 group by，甚至 join 这样的操作，对中间层的开发能力要求比较高；</li><li>对 proxy 端的压力比较大，尤其是很容易出现内存不够用和 CPU 瓶颈的问题。</li></ol><p>**另一种思路就是，**把各个分库拿到的数据，汇总到一个 MySQL 实例的一个表中，然后在这个汇总实例上做逻辑操作。</p><p>比如上面这条语句，执行流程可以类似这样：</p><ul><li>在汇总库上创建一个临时表 temp_ht，表里包含三个字段 v、k、t_modified；</li><li>在各个分库上执行</li></ul><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> v<span class="token punctuation">,</span>k<span class="token punctuation">,</span>t_modified <span class="token keyword">from</span> ht_x <span class="token keyword">where</span> k <span class="token operator">&gt;=</span> M <span class="token keyword">order</span> <span class="token keyword">by</span> t_modified <span class="token keyword">desc</span> <span class="token keyword">limit</span> <span class="token number">100</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><ul><li>把分库执行的结果插入到 temp_ht 表中；</li><li>执行</li></ul><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>select v from temp_ht order by t_modified desc limit 100;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>得到结果。</p><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20220828152038.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>在实践中，我们往往会发现每个分库的计算量都不饱和，所以会直接把临时表 temp_ht 放到 32 个分库中的某一个上。</strong></p><h4 id="什么时候会使用内部临时表" tabindex="-1"><a class="header-anchor" href="#什么时候会使用内部临时表" aria-hidden="true">#</a> 什么时候会使用内部临时表</h4><ol><li>如果对 group by 语句的结果没有排序要求，要在语句后面加 order by null；</li><li>尽量让 group by 过程用上表的索引，确认方法是 explain 结果里没有 Using temporary 和 Using filesort；</li><li>如果 group by 需要统计的数据量不大，尽量只使用内存临时表；也可以通过适当调大 tmp_table_size 参数，来避免用到磁盘临时表；</li><li>如果数据量实在太大，使用 SQL_BIG_RESULT 这个提示，来告诉优化器直接使用排序算法得到 group by 的结果。</li></ol><h3 id="自增主键为什么不是连续的" tabindex="-1"><a class="header-anchor" href="#自增主键为什么不是连续的" aria-hidden="true">#</a> 自增主键为什么不是连续的</h3><p><strong>表的结构定义存放在后缀名为.frm 的文件中，但是并不会保存自增值。</strong></p><p>在 MyISAM 引擎里面，自增值是被写在数据文件上的。而在 InnoDB 中，自增值是被记录在内存的。</p><p>InnoDB 中，只保证了自增 id 是递增的，但不保证是连续的。这么做是处于性能考虑：语句执行失败也不回退自增 id。</p><h3 id="自增-id-不够用了怎么办" tabindex="-1"><a class="header-anchor" href="#自增-id-不够用了怎么办" aria-hidden="true">#</a> 自增 ID 不够用了怎么办？</h3><h3 id="grant-之后为什么要跟着-flush-privilege" tabindex="-1"><a class="header-anchor" href="#grant-之后为什么要跟着-flush-privilege" aria-hidden="true">#</a> grant 之后为什么要跟着 flush privilege</h3><p>grant 语句会同时修改数据表和内存，判断权限的时候使用的是内存数据。因此，规范地使用 grant 和 revoke 语句，是不需要随后加上 flush privileges 语句的。</p><p>flush privileges 语句本身会用数据表的数据重建一份内存权限数据，所以在权限数据可能存在不一致的情况下再使用。而这种不一致往往是由于直接用 DML 语句操作系统权限表导致的，所以我们尽量不要使用这类语句。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>`,347),d={href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"},k={href:"https://xiaolincoding.com/mysql/",target:"_blank",rel:"noopener noreferrer"};function g(h,b){const s=o("ExternalLinkIcon");return i(),l("div",null,[c,n("ul",null,[n("li",null,[n("a",d,[a("《高性能 MySQL》"),e(s)])]),n("li",null,[n("a",u,[a("MySQL 实战 45 讲"),e(s)])]),n("li",null,[n("a",k,[a("图解 MySQL 介绍"),e(s)])])])])}const v=t(r,[["render",g],["__file","99.Mysql面试.html.vue"]]);export{v as default};
