import{_ as a}from"./plugin-vue_export-helper-c27b6911.js";import{r as l,o as r,c,a as e,b as t,d as o,e as s}from"./app-207caadd.js";const d={},i=s(`<h1 id="mysql-锁" tabindex="-1"><a class="header-anchor" href="#mysql-锁" aria-hidden="true">#</a> Mysql 锁</h1><figure><img src="https://raw.githubusercontent.com/dunwu/images/master/snap/20200716064947.png" alt="img" tabindex="0" loading="lazy"><figcaption>img</figcaption></figure><h2 id="悲观锁和乐观锁" tabindex="-1"><a class="header-anchor" href="#悲观锁和乐观锁" aria-hidden="true">#</a> 悲观锁和乐观锁</h2><p>确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，<strong>乐观锁和悲观锁是并发控制主要采用的技术手段。</strong></p><ul><li><strong><code>悲观锁</code></strong> - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 <ul><li>在查询完数据的时候就把事务锁起来，直到提交事务（<code>COMMIT</code>）</li><li>实现方式：<strong>使用数据库中的锁机制</strong>。</li></ul></li><li><strong><code>乐观锁</code></strong> - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 <ul><li>在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定</li><li>实现方式：<strong>使用 version 版本或者时间戳</strong>。</li></ul></li></ul><p>【示例】乐观锁示例</p><p>商品 goods 表中有一个字段 status，status 为 1 代表商品未被下单，status 为 2 代表商品已经被下单，那么我们对某个商品下单时必须确保该商品 status 为 1。假设商品的 id 为 1。</p><div class="language-sql line-numbers-mode" data-ext="sql"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token punctuation">(</span><span class="token keyword">status</span><span class="token punctuation">,</span><span class="token keyword">status</span><span class="token punctuation">,</span>version<span class="token punctuation">)</span> <span class="token keyword">from</span> t_goods <span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment">#{id}</span>

<span class="token keyword">update</span> t_goods
<span class="token keyword">set</span> <span class="token keyword">status</span><span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>version<span class="token operator">=</span>version<span class="token operator">+</span><span class="token number">1</span>
<span class="token keyword">where</span> id<span class="token operator">=</span><span class="token comment">#{id} and version=#{version};</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,8),p={href:"https://www.cnblogs.com/laoyeye/p/8097684.html",target:"_blank",rel:"noopener noreferrer"},g=s('<h2 id="表级锁和行级锁" tabindex="-1"><a class="header-anchor" href="#表级锁和行级锁" aria-hidden="true">#</a> 表级锁和行级锁</h2><p>从数据库的锁粒度来看，MySQL 中提供了两种封锁粒度：行级锁和表级锁。</p><ul><li><strong>表级锁（table lock）</strong> - 锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。</li><li><strong>行级锁（row lock）</strong> - 锁定指定的行记录。这样其它进程还是可以对同一个表中的其它记录进行操作。</li></ul><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。<strong>锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高</strong>。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此<strong>锁粒度越小，系统开销就越大</strong>。</p><p>在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><p>在 <code>InnoDB</code> 中，<strong>行锁是通过给索引上的索引项加锁来实现的</strong>。<strong>如果没有索引，<code>InnoDB</code> 将会通过隐藏的聚簇索引来对记录加锁</strong>。</p><h2 id="读写锁" tabindex="-1"><a class="header-anchor" href="#读写锁" aria-hidden="true">#</a> 读写锁</h2><ul><li>独享锁（Exclusive），简写为 X 锁，又称写锁。使用方式：<code>SELECT ... FOR UPDATE;</code></li><li>共享锁（Shared），简写为 S 锁，又称读锁。使用方式：<code>SELECT ... LOCK IN SHARE MODE;</code></li></ul><p>写锁和读锁的关系，简言之：<strong>独享锁存在，其他事务就不能做任何操作</strong>。</p><p><strong><code>InnoDB</code> 下的行锁、间隙锁、next-key 锁统统属于独享锁</strong>。</p><h2 id="意向锁" tabindex="-1"><a class="header-anchor" href="#意向锁" aria-hidden="true">#</a> 意向锁</h2><p><strong>当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁</strong>。使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><p><strong>意向锁是 <code>InnoDB</code> 自动加的，不需要用户干预</strong>。</p><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。</p><p>意向锁规定：</p><ul><li>IX/IS 是表锁；</li><li>X/S 是行锁。</li><li>一个事务在获得某个数据行的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行的 X 锁之前，必须先获得表的 IX 锁。</li></ul><p>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。</p><p>各种锁的兼容关系如下：</p><table><thead><tr><th style="text-align:center;">-</th><th style="text-align:center;">X</th><th style="text-align:center;">IX</th><th style="text-align:center;">S</th><th style="text-align:center;">IS</th></tr></thead><tbody><tr><td style="text-align:center;">X</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td></tr><tr><td style="text-align:center;">IX</td><td style="text-align:center;">❌</td><td style="text-align:center;">✔️️️️</td><td style="text-align:center;">❌</td><td style="text-align:center;">✔️️️️</td></tr><tr><td style="text-align:center;">S</td><td style="text-align:center;">❌</td><td style="text-align:center;">❌</td><td style="text-align:center;">✔️️️️</td><td style="text-align:center;">✔️️️️</td></tr><tr><td style="text-align:center;">IS</td><td style="text-align:center;">❌</td><td style="text-align:center;">✔️️️️</td><td style="text-align:center;">✔️️️️</td><td style="text-align:center;">✔️️️️</td></tr></tbody></table><p>解释如下：</p><ul><li>任意 IS/IX 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；</li><li>这里兼容关系针对的是表级锁，而表级的 IX 锁和行级的 X 锁兼容，两个事务可以对两个数据行加 X 锁。（事务 T1 想要对数据行 R1 加 X 锁，事务 T2 想要对同一个表的数据行 R2 加 X 锁，两个事务都需要对该表加 IX 锁，但是 IX 锁是兼容的，并且 IX 锁与行级的 X 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）</li></ul><h2 id="行锁" tabindex="-1"><a class="header-anchor" href="#行锁" aria-hidden="true">#</a> 行锁</h2><p>行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。</p><ul><li><code>Record Lock</code> - <strong>行锁对索引项加锁，若没有索引则使用表锁</strong>。</li><li><code>Gap Lock</code> - <strong>对索引项之间的间隙加锁</strong>。锁定索引之间的间隙，但是不包含索引本身。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：<code>SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;</code>。在 MySQL 中，gap lock 默认是开启的，即 <code>innodb_locks_unsafe_for_binlog</code> 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。</li><li><code>Next-key lock</code> -它是 <code>Record Lock</code> 和 <code>Gap Lock</code> 的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。它锁定一个前开后闭区间。</li></ul><p>只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock。在 <code>Select</code>、<code>Update</code> 和 <code>Delete</code> 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。</p><p>MVCC 不能解决幻读问题，<strong>Next-Key 锁就是为了解决幻读问题</strong>。在可重复读（<code>REPEATABLE READ</code>）隔离级别下，使用 <strong>MVCC + Next-Key 锁</strong> 可以解决幻读问题。</p><p>索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 <code>UPDATE</code>、<code>DELETE</code> 操作时，MySQL 不仅锁定 <code>WHERE</code> 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 <code>next-key lock</code>。</p><p>当两个事务同时执行，一个锁住了主键索引，在等待其他相关索引。另一个锁定了非主键索引，在等待主键索引。这样就会发生死锁。发生死锁后，<code>InnoDB</code> 一般都可以检测到，并使一个事务释放锁回退，另一个获取锁完成事务。</p><h2 id="参考资料" tabindex="-1"><a class="header-anchor" href="#参考资料" aria-hidden="true">#</a> 参考资料</h2>',29),h={href:"https://book.douban.com/subject/23008813/",target:"_blank",rel:"noopener noreferrer"},u={href:"https://time.geekbang.org/column/intro/139",target:"_blank",rel:"noopener noreferrer"},k={href:"https://time.geekbang.org/column/intro/100028001",target:"_blank",rel:"noopener noreferrer"},y={href:"https://github.com/CyC2018/Interview-Notebook/blob/master/notes/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86.md",target:"_blank",rel:"noopener noreferrer"},x={href:"https://juejin.im/post/5b55b842f265da0f9e589e79",target:"_blank",rel:"noopener noreferrer"},b={href:"https://www.cnblogs.com/laoyeye/p/8097684.html",target:"_blank",rel:"noopener noreferrer"};function m(_,f){const n=l("ExternalLinkIcon");return r(),c("div",null,[i,e("blockquote",null,[e("p",null,[t("更详细的乐观锁说可以参考："),e("a",p,[t("使用 mysql 乐观锁解决并发问题"),o(n)])])]),g,e("ul",null,[e("li",null,[e("a",h,[t("《高性能 MySQL》"),o(n)])]),e("li",null,[e("a",u,[t("MySQL 实战 45 讲"),o(n)])]),e("li",null,[e("a",k,[t("《Java 性能调优实战》"),o(n)])]),e("li",null,[e("a",y,[t("数据库系统原理"),o(n)])]),e("li",null,[e("a",x,[t("数据库两大神器【索引和锁】"),o(n)])]),e("li",null,[e("a",b,[t("使用 mysql 乐观锁解决并发问题"),o(n)])])])])}const v=a(d,[["render",m],["__file","05.Mysql锁.html.vue"]]);export{v as default};
