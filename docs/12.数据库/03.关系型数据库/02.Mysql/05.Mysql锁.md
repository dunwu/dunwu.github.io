---
icon: logos:mysql
title: Mysql 锁
date: 2020-09-07 07:54:19
order: 05
categories:
  - 数据库
  - 关系型数据库
  - Mysql
tags:
  - 数据库
  - 关系型数据库
  - Mysql
  - 锁
---

# Mysql 锁

> 不同存储引擎对于锁的支持粒度是不同的，由于 InnoDB 是 Mysql 的默认存储引擎，所以本文以 InnoDB 对于锁的支持进行阐述。

## 锁的分类

### 基于是否共享分类

InnoDB 实现标准行级锁定，其中根据锁是否能共享，可以把锁分为两类：

- 独享锁（Exclusive），简写为 X 锁，又称写锁。
  - 独占锁允许持有该锁的事务更新或删除行。
  - 使用方式：`SELECT ... FOR UPDATE;`
- 共享锁（Shared），简写为 S 锁，又称读锁。
  - 共享锁允许持有该锁的事务读取一行。
  - 使用方式：`SELECT ... LOCK IN SHARE MODE;`

写锁和读锁的关系，简言之：**如果存在独享锁，其他事务就不能做任何操作**。

> 注：InnoDB 下的行锁、间隙锁、next-key 锁统统属于独享锁。

### 基于加锁方式分类

确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性，**乐观锁和悲观锁是并发控制主要采用的技术手段。**

- **悲观锁** - 假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
  - 在查询完数据的时候就把事务锁起来，直到提交事务（`COMMIT`）
  - 实现方式：**使用数据库中的锁机制**。
- **乐观锁** - 假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。
  - 在修改数据的时候把事务锁起来，通过 version 的方式来进行锁定
  - 实现方式：**使用 version 版本或者时间戳**。

【示例】乐观锁示例

商品 goods 表中有一个字段 status，status 为 1 代表商品未被下单，status 为 2 代表商品已经被下单，那么我们对某个商品下单时必须确保该商品 status 为 1。假设商品的 id 为 1。

```sql
select (status,status,version) from t_goods where id=#{id}

update t_goods
set status=2,version=version+1
where id=#{id} and version=#{version};
```

> 更详细的乐观锁说可以参考：[使用 mysql 乐观锁解决并发问题](https://www.cnblogs.com/laoyeye/p/8097684.html)

### 基于锁粒度分类

数据库锁是通过互斥的方式处理并发访问问题。**根据加锁的范围，MySQL 的锁大致可以分成全局锁、表级锁和行锁三类**。

**从数据库的锁粒度来看，MySql 中的锁可以分为三类：全局锁、表级锁和行锁**。

- **全局锁** - 『全局锁』会锁定整个数据库。
- **表级锁（table lock）** - 『表级锁』锁定整张表。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。
- **行级锁（row lock）** - 『行级锁』锁定指定的行记录。这样其它线程还是可以对同一个表中的其它行记录进行操作。

应该尽量只锁定需要修改的那部分数据，而不是所有的资源。**锁定的数据量越少，锁竞争的发生频率就越小，系统的并发程度就越高**。但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此**锁粒度越大，系统开销就越大**。

在选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。

## 全局锁

**『全局锁』会锁定整个数据库**。

要给整个数据库加全局锁，可以执行以下命令：

```sql
flush tables with read lock
```

执行命名后，整个库处于只读状态，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。

如果要释放全局锁，可以执行以下命令：

```sql
unlock tables
```

此外，在客户端断开的时候会自动释放锁。

**全局锁的典型使用场景是，做全库逻辑备份。**

官方自带的逻辑备份工具是 mysqldump。当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。而由于 MVCC 的支持，这个过程中数据是可以正常更新的。对于全部是 InnoDB 引擎的库，建议选择使用 `–single-transaction` 参数，对应用会更友好。如果有的表使用了不支持事务的引擎，那么备份就只能通过 FTWRL 方法。

## 表级锁

**『表级锁』锁定整张表**。用户对表进行写操作前，需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他用户才能获得读锁，读锁之间不会相互阻塞。MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。

### 表锁

**表锁的语法是 `lock tables … read/write`**，示例如下：

```sql
// 为 xxx 表加 MDL 读锁
lock tables xxx read;

// 为 xxx 表加 MDL 写锁
lock tables xxx write;
```

与 FTWRL 类似，可以用 `unlock tables` 主动释放锁，也可以在客户端断开的时候自动释放。

表锁一般是在数据库引擎不支持行锁的时候才会被用到的。如果你发现应用程序里有 `lock tables` 这样的语句，需要追查一下，比较可能的情况是：

- 要么是你的系统现在还在用 MyISAM 这类不支持事务的引擎，那要安排升级换引擎；
- 要么是你的引擎升级了，但是代码还没升级。我见过这样的情况，最后业务开发就是把 `lock tables` 和 `unlock tables` 改成 `begin` 和 `commit`，问题就解决了。

### 元数据锁（MDL）

元数据锁，英文为 metadata lock，缩写为 MDL。MySQL 5.5 版本中引入了 MDL。MDL 的作用是，保证读写的正确性。**MDL 不需要显式使用，在访问一个表的时候会被自动加上**。

- 对一个表做**『增删改查』**操作的时候，加 **MDL 读锁**。读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。
- 对一个表做**『结构变更』**操作的时候，加 **MDL 写锁**。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。

**MDL 会直到事务提交才释放**。在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。

如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那么在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：

1. 首先，线程 A 先启用了事务（但是一直不提交），然后执行一条 `SELECT` 语句，此时就先对该表加上 MDL 读锁；
2. 然后，线程 B 也执行了同样的 `SELECT` 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 接着，线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，这时线程 C 就无法申请到 MDL 写锁，就会被阻塞，

那么在线程 C 阻塞后，后续有对该表的 SELECT 语句，就都会被阻塞。如果此时有大量该表的 SELECT 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

> 为什么线程 C 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？

这是因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。

所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。

### 意向锁（Intention Lock）

**当存在表级锁和行级锁的情况下，必须先申请意向锁（表级锁，但不是真的加锁），再获取行级锁**。使用意向锁可以更容易地支持多粒度封锁。**意向锁是 `InnoDB` 自动加的，不需要用户干预**。

在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。

意向锁规定：

- `IX` / `IS` 是表锁；
- `X` / `S` 是行锁。
- 一个事务在获得某个数据行的 `S` 锁之前，必须先获得表的 `IS` 锁或者更强的锁；
- 一个事务在获得某个数据行的 `X` 锁之前，必须先获得表的 `IX` 锁。

通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了 X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T 加 X 锁失败。

各种锁的兼容关系如下：

|  -  |  X  |  IX   |   S   |  IS   |
| :-: | :-: | :---: | :---: | :---: |
|  X  | ❌  |  ❌   |  ❌   |  ❌   |
| IX  | ❌  | ✔️️️️ |  ❌   | ✔️️️️ |
|  S  | ❌  |  ❌   | ✔️️️️ | ✔️️️️ |
| IS  | ❌  | ✔️️️️ | ✔️️️️ | ✔️️️️ |

解释如下：

- 任意 `IX` / `IS` 锁之间都是兼容的，因为它们只表示想要对表加锁，而不是真正加锁；
- 这里兼容关系针对的是表级锁，而表级的 `IX` 锁和行级的 `X` 锁兼容，两个事务可以对两个数据行加 `X` 锁。（事务 T1 想要对数据行 R1 加 `X` 锁，事务 T2 想要对同一个表的数据行 R2 加 `X` 锁，两个事务都需要对该表加 `IX` 锁，但是 `IX` 锁是兼容的，并且 `IX` 锁与行级的 `X` 锁也是兼容的，因此两个事务都能加锁成功，对同一个表中的两个数据行做修改。）

### 自增锁（AUTO-INC）

表里的主键通常都会设置成自增的，这是通过对主键字段声明 `AUTO_INCREMENT` 属性实现的。之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。

AUTO-INC 锁是特殊的表锁机制，锁**不是在一个事务提交后才释放，而是在执行完插入语句后就会立即释放**。

**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。

但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。

因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。

一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

InnoDB 存储引擎提供了个 `innodb_autoinc_lock_mode` 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。

- 当 `innodb_autoinc_lock_mode = 0`，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 `innodb_autoinc_lock_mode = 2`，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 `innodb_autoinc_lock_mode = 1`：
  - 普通 `insert` 语句，自增锁在申请之后就马上释放；
  - 类似 `insert … select` 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；

以上模式中，`innodb_autoinc_lock_mode = 2` 是性能最高的方式，但是当搭配 binlog 的日志格式是 statement 一起使用的时候，在「主从复制的场景」中会发生**数据不一致的问题**。

## 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

在 InnoDB 引擎中，**行锁是通过给索引上的索引项加锁来实现的**。**如果没有索引，`InnoDB` 将会通过隐藏的聚簇索引来对记录加锁**。此外，在 InnoDB 引擎中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。因此，如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。

### 记录锁（Record Lock）

**Record Lock 称为记录锁，锁定一个记录上的索引，而不是记录本身**。如果表没有设置索引，InnoDB 会自动在主键上创建隐藏的聚簇索引，因此 Record Lock 依然可以使用。

Record Lock 是有 S 锁和 X 锁之分的：

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。

举个例子，当一个事务执行了下面这条语句：

```sql
mysql > begin;
mysql > select * from t_test where id = 1 for update;
```

就是对 t_test 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。

### 间隙锁（Gap Lock）

Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。

**间隙锁定索引之间的间隙，但是不包含索引本身**。例如当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15。

```plsql
SELECT c FROM t WHERE c BETWEEN 10 and 20 FOR UPDATE;
```

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系**。

在 MySQL 中，间隙锁默认是开启的，即 `innodb_locks_unsafe_for_binlog` 参数值是 `disable` 的，且 MySQL 中默认的是 RR 事务隔离级别。

### Next-Key Lock

Next-Key Lock 是记录锁和间隙锁的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙（它锁定一个前开后闭区间）。

例如一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：

```
(-∞, 10]
(10, 11]
(11, 13]
(13, 20]
(20, +∞)
```

所以，next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。MVCC 不能解决幻读问题，**Next-Key 锁就是为了解决幻读问题而提出的**。在可重复读（`REPEATABLE READ`）隔离级别下，使用**MVCC + Next-Key 锁**可以解决幻读问题。

只有可重复读、串行化隔离级别下的特定操作才会取得间隙锁或 Next-Key Lock。在 `Select`、`Update` 和 `Delete` 时，除了基于唯一索引的查询之外，其它索引查询时都会获取间隙锁或 Next-Key Lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用间隙锁或 Next-Key Lock。

索引分为主键索引和非主键索引两种，如果一条 SQL 语句操作了主键索引，MySQL 就会锁定这条主键索引；如果一条语句操作了非主键索引，MySQL 会先锁定该非主键索引，再锁定相关的主键索引。在 `UPDATE`、`DELETE` 操作时，MySQL 不仅锁定 `WHERE` 条件扫描过的所有索引记录，而且会锁定相邻的键值，即所谓的 Next-Key Lock。

## 死锁

**『死锁』是指两个或多个事务竞争同一资源，并请求锁定对方占用的资源，从而导致恶性循环的现象**。

产生死锁的场景：

- 当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。

- 多个事务同时锁定同一个资源时，也会产生死锁。

### 死锁的原因

行锁的具体实现算法有三种：record lock、gap lock 以及 next-key lock。record lock 是专门对索引项加锁；gap lock 是对索引项之间的间隙加锁；next-key lock 则是前面两种的组合，对索引项以其之间的间隙加锁。

只在可重复读或以上隔离级别下的特定操作才会取得 gap lock 或 next-key lock，在 Select、Update 和 Delete 时，除了基于唯一索引的查询之外，其它索引查询时都会获取 gap lock 或 next-key lock，即锁住其扫描的范围。主键索引也属于唯一索引，所以主键索引是不会使用 gap lock 或 next-key lock。

在 MySQL 中，gap lock 默认是开启的，即 innodb_locks_unsafe_for_binlog 参数值是 disable 的，且 MySQL 中默认的是 RR 事务隔离级别。

当我们执行以下查询 SQL 时，由于 order_no 列为非唯一索引，此时又是 RR 事务隔离级别，所以 SELECT 的加锁类型为 gap lock，这里的 gap 范围是 (4,+∞）。

> SELECT id FROM `demo`.`order_record` where `order_no` = 4 for update;

执行查询 SQL 语句获取的 gap lock 并不会导致阻塞，而当我们执行以下插入 SQL 时，会在插入间隙上再次获取插入意向锁。插入意向锁其实也是一种 gap 锁，它与 gap lock 是冲突的，所以当其它事务持有该间隙的 gap lock 时，需要等待其它事务释放 gap lock 之后，才能获取到插入意向锁。

以上事务 A 和事务 B 都持有间隙 (4,+∞）的 gap 锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的 gap 锁释放，于是就造成了循环等待，导致死锁。

> INSERT INTO `demo`.`order_record`(`order_no`, `status`, `create_date`) VALUES (5, 1, ‘2019-07-13 10:57:03’);

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200630153139.png)

**另一个死锁场景**

InnoDB 存储引擎的主键索引为聚簇索引，其它索引为辅助索引。如果使用辅助索引来更新数据库，就需要使用聚簇索引来更新数据库字段。如果两个更新事务使用了不同的辅助索引，或一个使用了辅助索引，一个使用了聚簇索引，就都有可能导致锁资源的循环等待。由于本身两个事务是互斥，也就构成了以上死锁的四个必要条件了。

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154606.png)

出现死锁的步骤：

![img](https://raw.githubusercontent.com/dunwu/images/master/snap/20200630154619.png)

综上可知，在更新操作时，我们应该尽量使用主键来更新表字段，这样可以有效避免一些不必要的死锁发生。

### 避免死锁

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。

预防死锁的注意事项：

- 更新表时，**尽量使用主键更新**；
- **避免长事务**，尽量将长事务拆解，可以降低与其它事务发生冲突的概率；
- **设置合理的锁等待超时参数**，我们可以通过 `innodb_lock_wait_timeout` 设置合理的等待超时阈值，特别是在一些高并发的业务中，我们可以尽量将该值设置得小一些，避免大量事务等待，占用系统资源，造成严重的性能开销。
- 在编程中**尽量按照固定的顺序来处理数据库记录**，假设有两个更新操作，分别更新两条相同的记录，但更新顺序不一样，有可能导致死锁；
- 在允许幻读和不可重复读的情况下，尽量使用 RC 事务隔离级别，可以避免 Gap Lock 导致的死锁问题；
- 还可以使用其它的方式来代替数据库实现幂等性校验。例如，使用 Redis 以及 ZooKeeper 来实现，运行效率比数据库更佳。

### 解决死锁

当出现死锁以后，有两种策略：

- 一种策略是，**设置事务等待锁的超时时间**。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置。
- 另一种策略是，**开启死锁检测**，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 `on`，表示开启这个逻辑。

在 InnoDB 中，`innodb_lock_wait_timeout` 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。

但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。

所以，正常情况下我们还是要采用第二种策略，即：主动死锁检测，而且 `innodb_deadlock_detect` 的默认值本身就是 on。为了解决死锁问题，不同数据库实现了各自的死锁检测和超时机制。InnoDB 的处理策略是：**将持有最少行级排它锁的事务进行回滚**。

主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。因此，死锁检测可能会耗费大量的 CPU。

## 参考资料

- [《高性能 MySQL》](https://book.douban.com/subject/23008813/)
- [MySQL 实战 45 讲](https://time.geekbang.org/column/intro/139)
- [《Java 性能调优实战》](https://time.geekbang.org/column/intro/100028001)
- [数据库系统原理](https://github.com/CyC2018/Interview-Notebook/blob/master/notes/数据库系统原理.md)
- [数据库两大神器【索引和锁】](https://juejin.im/post/5b55b842f265da0f9e589e79)
- [使用 mysql 乐观锁解决并发问题](https://www.cnblogs.com/laoyeye/p/8097684.html)
