---
icon: logos:mysql
title: Mysql 面试
date: 2020-09-12 10:43:53
order: 00
categories:
  - 数据库
  - 关系型数据库
  - Mysql
tags:
  - 数据库
  - 关系型数据库
  - Mysql
  - 面试
---

# Mysql 面试

## 架构

### 一条 SQL 查询语句是如何执行的？

![](https://raw.githubusercontent.com/dunwu/images/dev/snap/20220720195101.png)

- **连接器**：连接器负责跟客户端建立连接、获取权限、维持和管理连接。
- **查询缓存**：命中缓存，则直接返回结果。弊大于利，因为失效非常频繁——任何更新都会清空查询缓存。
- **分析器**
  - **词法分析**：解析 SQL 关键字
  - **语法分析**：生成一颗对应的语法解析树
- **优化器**
  - 根据语法树**生成多种执行计划**
  - **索引选择**：根据策略选择最优方式
- **执行器**
  - 校验读写权限
  - 根据执行计划，调用存储引擎的 API 来执行查询
- **存储引擎**：存储数据，提供读写接口

### 一条 SQL 更新语句是如何执行的？

更新流程和查询的流程大致相同，不同之处在于：更新流程还涉及两个重要的日志模块：

- redo log（重做日志）
- binlog（归档日志）

## 事务

### 事务到底是隔离的还是不隔离的

### “快照”在 MVCC 里是怎么工作的？

## 索引

### 实现索引有哪些常见数据数据？

- 哈希
- 有序数组
- B+树

### 普通索引和唯一索引，应该怎么选择？

### MySQL 为什么有时候会选错索引

### 怎么给字符串字段加索引？

## `order by` 是怎么工作的？

## 锁

### 全局锁和表锁 ：给表加个字段怎么有这么多阻碍？

### 怎么减少行锁对性能的影响？

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。

### 什么是死锁？如何检测死锁

当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为**死锁**。

当出现死锁以后，有两种策略：

- **进入等待，直到超时**。这个超时时间可以通过参数 `innodb_lock_wait_timeout` 来设置。
  - 在 InnoDB 中，`innodb_lock_wait_timeout` 的默认值是 50s，意味着如果此策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。
  - 但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。
- **发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行**。将参数 `innodb_deadlock_detect` 设置为 on，表示开启这个逻辑。
  - 主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。
  - 极端情况下，如果所有事务都要更新同一行：每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。

减少死锁的主要方向，就是控制访问相同资源的并发事务量。

### 为什么我只改一行的语句，锁这么多？

## 日志

### 为什么表数据删掉一半，表文件大小不变？

【问题】数据库占用空间太大，我把一个最大的表删掉了一半的数据，怎么表文件的大小还是没变？

表数据既可以存在共享表空间里，也可以是单独的文件。这个行为是由参数 `innodb_file_per_table` 控制的：

1. 这个参数设置为 OFF 表示的是，表的数据放在系统共享表空间，也就是跟数据字典放在一起；
2. 这个参数设置为 ON 表示的是，每个 InnoDB 表数据存储在一个以 .ibd 为后缀的文件中。

从 MySQL 5.6.6 版本开始，它的默认值就是 ON 了。

我建议你不论使用 MySQL 的哪个版本，都将这个值设置为 ON。因为，一个表单独存储为一个文件更容易管理，而且在你不需要这个表的时候，通过 drop table 命令，系统就会直接删除这个文件。而如果是放在共享表空间中，即使表删掉了，空间也是不会回收的。

所以，**将 innodb_file_per_table 设置为 ON，是推荐做法，我们接下来的讨论都是基于这个设置展开的。**

我们在删除整个表的时候，可以使用 drop table 命令回收表空间。但是，我们遇到的更多的删除数据的场景是删除某些行，这时就遇到了我们文章开头的问题：表中的数据被删除了，但是表空间却没有被回收。

**插入和删除操作可能会造成空洞**。

- 插入时，如果插入位置所在页已满，需要申请新页面。
- 删除时，不会删除所在页，而是将记录在页面的位置标记为可重用。

所以，如果能够把这些空洞去掉，就能达到收缩表空间的目的。

要达到收缩空洞的目的，可以使用重建表的方式。

## HA

### Mysql 是怎么保证数据不丢的

### Mysql 是怎么保证主备一致的

## 优化

### `count(*)` 这么慢，我该怎么办？

### 为什么这些 SQL 语句逻辑相同，性能却差异巨大？

### MySQL 有哪些“饮鸩止渴”提高性能的方法？

### 如果 MySQL 出现了 IO 性能瓶颈，可以通过哪些方法来提升性能

## 参考资料

- [《高性能 MySQL》](https://book.douban.com/subject/23008813/)
- [MySQL 实战 45 讲](https://time.geekbang.org/column/intro/139)