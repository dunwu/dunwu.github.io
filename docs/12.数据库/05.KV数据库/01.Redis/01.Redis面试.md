---
title: Redis 面试
date: 2020-07-13 17:03:42
order: 01
categories:
  - 数据库
  - KV数据库
  - Redis
tags:
  - 数据库
  - KV数据库
  - Redis
  - 面试
---

# Redis 面试

## Redis 简介

### 什么是 Redis

Redis 是一种内存数据库，对数据的读写操作都是在内存中完成，因此**读写速度非常快**，常用于**缓存，消息队列、分布式锁等场景**。

Redis 提供了多种数据类型，如：String(字符串)、Hash(哈希)、 List (列表)、Set(集合)、Zset(有序集合)、Bitmaps（位图）、HyperLogLog（基数统计）、GEO（地理空间）、Stream（流）。Redis 对数据类型的操作都是**原子性**的，因为执行命令由单线程负责的，不存在并发竞争的问题。

除此之外，Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。

### Redis 的优势

- 性能极高 – Redis 能读的速度是 110000 次/s，写的速度是 81000 次/s。
- 丰富的数据类型 - 支持字符串、列表、集合、有序集合、散列表。
- 原子 - Redis 的所有操作都是原子性的。单个操作是原子性的。多个操作也支持事务，即原子性，通过 MULTI 和 EXEC 指令包起来。
- 持久化 - Redis 支持数据的持久化。可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
- 备份 - Redis 支持数据的备份，即 master-slave 模式的数据备份。
- 丰富的特性 - Redis 还支持发布订阅, 通知, key 过期等等特性。

### Redis 有哪些使用场景

- **缓存** - 将热点数据放到内存中，设置内存的最大使用量以及过期淘汰策略来保证缓存的命中率。
- **计数器** - Redis 这种内存数据库能支持计数器频繁的读写操作。
- **应用限流** - 限制一个网站访问流量。
- **消息队列** - 使用 List 数据类型，它是双向链表。
- **查找表** - 使用 HASH 数据类型。
- **交集运算** - 使用 SET 类型，例如求两个用户的共同好友。
- **排行榜** - 使用 ZSET 数据类型。
- **分布式 Session** - 多个应用服务器的 Session 都存储到 Redis 中来保证 Session 的一致性。
- **分布式锁** - 除了可以使用 SETNX 实现分布式锁之外，还可以使用官方提供的 RedLock 分布式锁实现。

### 为什么用 Redis 作为缓存

主要是因为 **Redis 具备「高性能」和「高并发」两种特性**。

**_1、Redis 具备高性能_**

假如用户第一次访问 MySQL 中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据缓存在 Redis 中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了，操作 Redis 缓存就是直接操作内存，所以速度相当快。

如果 MySQL 中的对应数据改变的之后，同步改变 Redis 缓存中相应的数据即可，不过这里会有 Redis 和 MySQL 双写一致性的问题，后面我们会提到。

**_2、 Redis 具备高并发_**

单台设备的 Redis 的 QPS（Query Per Second，每秒钟处理完请求的次数） 是 MySQL 的 10 倍，Redis 单机的 QPS 能轻松破 10w，而 MySQL 单机的 QPS 很难破 1w。

### Redis 和 Memcached 有什么区别

Redis 与 Memcached 的**共性**：

1. 都是内存数据库，一般都用来当做缓存使用。
2. 都有过期策略。
3. 两者的性能都非常高。

Redis 与 Memcached **差异**：

|          | Redis                                                         | Memcached                                                                                                                                        |
| -------- | ------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| 数据类型 | 支持数据类型更丰富：String、Hash、List、Set、ZSet 等          | 只支持 KV 数据类型                                                                                                                               |
| 持久化   | 支持两种持久化策略：RDB 快照和 AOF 日志                       | 不支持持久化，一旦重启或宕机就会丢失数据                                                                                                         |
| 分布式   | 支持分布式                                                    | 本身不支持分布式，只能通过在客户端使用像一致性哈希这样的分布式算法来实现分布式存储，这种方式在存储和查询时都需要先在客户端计算一次数据所在的节点 |
| 性能     | Redis 的读写采用单线程，因此存储小数据时比 Memcached 性能更高 | 在 100k 以上的数据中，Memcached 性能要高于 Redis                                                                                                 |
| 其他功能 | 支持发布订阅模型、Lua 脚本、事务等功能                        | 不支持                                                                                                                                           |

### Redis 为什么快

Redis 单机 QPS 能达到 100000。

Redis 是单线程模型（Redis 6.0 已经支持多线程模型），为什么还能有这么高的并发？

- Redis 完全基于内存操作。
- Redis 数据结构简单。
- 采用单线程，避免线程上下文切换和竞争。
- 使用 I/O 多路复用模型（非阻塞 I/O）。

> I/O 多路复用
>
> I/O 多路复用模型是利用 select、poll、epoll 可以同时监察多个流的 I/O 事件的能力，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有 I/O 事件时，就从阻塞态中唤醒，于是程序就会轮询一遍所有的流（epoll 是只轮询那些真正发出了事件的流），并且只依次顺序的处理就绪的流，这种做法就避免了大量的无用操作。

## Redis 数据类型

### Redis 支持哪些数据类型

Redis 支持的五种基本数据类型：

- **String（字符串）** - 典型应用场景：缓存对象、计数器、分布式锁、共享 session 信息等。
- **Hash（哈希）** - 典型应用场景：缓存对象、购物车等。
- **List（列表）** - 典型应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- **Set（集合）** - 典型应用场景：聚合计算（并集、交集、差集），如点赞、共同关注、抽奖活动等。
- **Zset（有序集合）** - 典型应用场景：排序场景，如排行榜、电话和姓名排序等。

随着版本升级，Redis 支持的四种扩展数据类型：

- BitMap（2.2 版新增） - 二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
- HyperLogLog（2.8 版新增） - 海量数据基数统计的场景，比如百万级网页 UV 计数等；
- GEO（3.2 版新增） - 存储地理位置信息的场景，比如滴滴叫车；
- Stream（5.0 版新增） - 消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息 ID，支持以消费组形式消费数据。

### Redis 五种基本数据类型是如何实现的

#### String 类型内部实现

String 类型的底层的数据结构实现主要是 SDS（简单动态字符串）。 SDS 和我们认识的 C 字符串不太一样，之所以没有使用 C 语言的字符串表示，因为 SDS 相比于 C 的原生字符串：

- **SDS 不仅可以保存文本数据，还可以保存二进制数据**。因为 SDS 使用 len 属性的值而不是空字符来判断字符串是否结束，并且 SDS 的所有 API 都会以处理二进制的方式来处理 SDS 存放在 buf[] 数组里的数据。所以 SDS 不光能存放文本数据，而且能保存图片、音频、视频、压缩文件这样的二进制数据。
- **SDS 获取字符串长度的时间复杂度是 O(1)**。因为 C 语言的字符串并不记录自身长度，所以获取长度的复杂度为 O(n)；而 SDS 结构里用 len 属性记录了字符串长度，所以复杂度为 O(1)。
- **Redis 的 SDS API 是安全的，拼接字符串不会造成缓冲区溢出**。因为 SDS 在拼接字符串之前会检查 SDS 空间是否满足要求，如果空间不够会自动扩容，所以不会导致缓冲区溢出的问题。

#### List 类型内部实现

List 类型的底层数据结构是由**双向链表或压缩列表**实现的：

- 如果列表的元素个数小于 512 个（默认值，可由 list-max-ziplist-entries 配置），列表每个元素的值都小于 64 字节（默认值，可由 list-max-ziplist-value 配置），Redis 会使用**压缩列表**作为 List 类型的底层数据结构；
- 如果列表的元素不满足上面的条件，Redis 会使用**双向链表**作为 List 类型的底层数据结构；

但是**在 Redis 3.2 版本之后，List 数据类型底层数据结构就只由 quicklist 实现了，替代了双向链表和压缩列表**。

#### Hash 类型内部实现

Hash 类型的底层数据结构是由**压缩列表或哈希表**实现的：

- 如果哈希类型元素个数小于 512 个（默认值，可由 hash-max-ziplist-entries 配置），所有值小于 64 字节（默认值，可由 hash-max-ziplist-value 配置）的话，Redis 会使用**压缩列表**作为 Hash 类型的底层数据结构；
- 如果哈希类型元素不满足上面条件，Redis 会使用**哈希表**作为 Hash 类型的底层数据结构。

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了**。

#### Set 类型内部实现

Set 类型的底层数据结构是由**哈希表或整数集合**实现的：

- 如果集合中的元素都是整数且元素个数小于 512 （默认值，set-maxintset-entries 配置）个，Redis 会使用**整数集合**作为 Set 类型的底层数据结构；
- 如果集合中的元素不满足上面条件，则 Redis 使用**哈希表**作为 Set 类型的底层数据结构。

#### ZSet 类型内部实现

Zset 类型的底层数据结构是由**压缩列表或跳表**实现的：

- 如果有序集合的元素个数小于 128 个，并且每个元素的值小于 64 字节时，Redis 会使用**压缩列表**作为 Zset 类型的底层数据结构；
- 如果有序集合的元素不满足上面的条件，Redis 会使用**跳表**作为 Zset 类型的底层数据结构；

**在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。**

## Redis Client

Redis 社区中有多种编程语言的客户端，可以在这里查找合适的客户端：[Redis 官方罗列的客户端清单](https://redis.io/clients)

redis 官方推荐的 Java Redis Client：

- [jedis](https://github.com/xetorthio/jedis) - 最流行的 Redis Java 客户端
- [redisson](https://github.com/redisson/redisson) - 额外提供了很多的分布式服务特性，如：分布式锁、分布式 Java 常用对象（BitSet、BlockingQueue、CountDownLatch 等）
- [lettuce](https://github.com/lettuce-io/lettuce-core) - Spring Boot 2.0 默认 Redis 客户端

## Redis 内存淘汰

【问题】

- Redis 有哪些内存淘汰策略？
- 这些淘汰策略分别适用于什么场景？
- Redis 有哪些删除失效 key 的方法？
- 如何设置 Redis 中键的过期时间？
- 如果让你实现一个 LRU 算法，怎么做？

---

【解答】

（1）Redis 过期策略是：**定期删除+惰性删除**。

- 消极方法（passive way），在主键被访问时如果发现它已经失效，那么就删除它。
- 主动方法（active way），定期从设置了失效时间的主键中选择一部分失效的主键删除。

（2）Redis 内存淘汰策略：

- **`noeviction`** - 当内存使用达到阈值的时候，所有引起申请内存的命令会报错。这是 Redis 默认的策略。
- **`allkeys-lru`** - 在主键空间中，优先移除最近未使用的 key。
- **`allkeys-random`** - 在主键空间中，随机移除某个 key。
- **`volatile-lru`** - 在设置了过期时间的键空间中，优先移除最近未使用的 key。
- **`volatile-random`** - 在设置了过期时间的键空间中，随机移除某个 key。
- **`volatile-ttl`** - 在设置了过期时间的键空间中，具有更早过期时间的 key 优先移除。

（3）如何选择内存淘汰策略：

- 如果数据呈现幂等分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用 `allkeys-lru`。
- 如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用 `allkeys-random`。
- `volatile-lru` 策略和 `volatile-random` 策略适合我们将一个 Redis 实例既应用于缓存和又应用于持久化存储的时候，然而我们也可以通过使用两个 Redis 实例来达到相同的效果。
- 将 key 设置过期时间实际上会消耗更多的内存，因此我们建议使用 `allkeys-lru` 策略从而更有效率的使用内存。

（4）LRU 算法实现思路：可以继承 LinkedHashMap，并覆写 removeEldestEntry 方法来实现一个最简单的 LRUCache

## Redis 持久化

【问题】

- Redis 有几种持久化方式？
- Redis 的不同持久化方式的特性和原理是什么？
- RDB 和 AOF 各有什么优缺点？分别适用于什么样的场景？
- Redis 执行持久化时，可以处理请求吗？
- AOF 有几种同步频率？

---

【解答】

（1）Redis 支持两种持久化方式：RDB 和 AOF。

（2）RDB 即某一时刻的二进制数据快照。

Redis 会周期性生成 RDB 文件。

生成 RDB 流程：Redis fork 一个子进程，负责生成 RDB；生成 RDB 采用 Copy On Write 模式，此时，如果收到写请求，会在原副本上操作，不影响工作。

RDB 只能恢复生成快照时刻的数据，之后的数据无法恢复。生成 RDB 的资源开销高昂。RDB 适合做冷备。

（3）AOF 会将写命令不断追加到 AOF 文本日志末尾。

AOF 丢数据比 RDB 少，但文件会比 RDB 文件大很多。

一般，AOF 设置 `appendfsync` 同步频率为 **`everysec`** 即可。

（4）RDB or AOF

建议同时使用 RDB 和 AOF。用 AOF 来保证数据不丢失，作为数据恢复的第一选择; 用 RDB 来做不同程度的冷备，在 AOF 文件都丢失或损坏不可用的时候，还可以使用 RDB 来进行快速的数据恢复。

## Redis 事务

【问题】

- Redis 的并发竞争问题是什么？如何解决这个问题？
- Redis 支持事务吗？
- Redis 事务是严格意义的事务吗？Redis 为什么不支持回滚。
- Redis 事务如何工作？
- 了解 Redis 事务中的 CAS 行为吗？

【解答】

**Redis 提供的不是严格的事务，Redis 只保证串行执行命令，并且能保证全部执行，但是执行命令失败时并不会回滚，而是会继续执行下去**。

Redis 不支持回滚的理由：

- Redis 命令只会因为错误的语法而失败，或是命令用在了错误类型的键上面。
- 因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。

`MULTI` 、 `EXEC` 、 `DISCARD` 和 `WATCH` 是 Redis 事务相关的命令。

Redis 有天然解决这个并发竞争问题的类 CAS 乐观锁方案：每次要**写之前，先判断**一下当前这个 value 的时间戳是否比缓存里的 value 的时间戳要新。如果是的话，那么可以写，否则，就不能用旧的数据覆盖新的数据。

## Redis 管道

【问题】

- 除了事务，还有其他批量执行 Redis 命令的方式吗？

【解答】

Redis 是一种基于 C/S 模型以及请求/响应协议的 TCP 服务。Redis 支持管道技术。管道技术允许请求以异步方式发送，即旧请求的应答还未返回的情况下，允许发送新请求。这种方式可以大大提高传输效率。使用管道发送命令时，Redis Server 会将部分请求放到缓存队列中（占用内存），执行完毕后一次性发送结果。如果需要发送大量的命令，会占用大量的内存，因此应该按照合理数量分批次的处理。

## Redis 高并发

【问题】

- Redis 是单线程模型，为何吞吐量还很高？
- Redis 的 IO 多路复用原理是什么？
- Redis 集群如何分片和寻址？
- Redis 集群如何扩展？
- Redis 集群如何保证数据一致？
- Redis 集群如何规划？你们公司的生产环境上如何部署 Redis 集群？

---

【解答】

（1）单线程

Redis 为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis 单机吞吐量也很高，能达到几万 QPS。

Redis 单线程模型，依然有很高的并发吞吐，原因在于：

- Redis 读写都是内存操作。
- Redis 基于**非阻塞的 IO 多路复用机制**，同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。
- 单线程，避免了线程创建、销毁、上下文切换的开销，并且避免了资源竞争。

（2）扩展并发吞吐量、存储容量

Redis 的高性能（扩展并发吞吐量、存储容量）通过主从架构来实现。

Redis 集群采用主从模型，提供复制和故障转移功能，来保证 Redis 集群的高可用。通常情况，一主多从模式已经可以满足大部分项目的需要。根据实际的并发量，可以通过增加节点来扩展并发吞吐。

一主多从模式下，主节点负责写操作（单机几万 QPS），从节点负责查询操作（单机十万 QPS）。

进一步，如果需要缓存大量数据，就需要分区（sharding）。Redis 集群通过划分虚拟 hash 槽来分片，每个主节点负责一定范围的 hash 槽。当需要扩展集群节点时，重新分配 hash 槽即可，redis-trib 会自动迁移变更 hash 槽中所属的 key。

（3）Redis 集群数据一致性

Redis 集群基于复制特性实现节点间的数据一致性。

## Redis 复制

【问题】

- Redis 复制的工作原理？Redis 旧版复制和新版复制有何不同？
- Redis 主从节点间如何复制数据？
- Redis 的数据一致性是强一致性吗？

---

【解答】

（1）旧版复制基于 `SYNC` 命令实现。分为同步（sync）和命令传播（command propagate）两个操作。这种方式存在缺陷：不能高效处理断线重连后的复制情况。

（2）新版复制基于 `PSYNC` 命令实现。同步操作分为了两块：

- **`完整重同步（full resychronization）`** 用于初次复制；
- **`部分重同步（partial resychronization）`** 用于断线后重复制。
  - 主从服务器的**复制偏移量（replication offset）**
  - 主服务器的**复制积压缓冲区（replication backlog）**
  - **服务器的运行 ID**

（3）Redis 集群主从节点复制的工作流程：

- 步骤 1. 设置主从服务器
- 步骤 2. 主从服务器建立 TCP 连接。
- 步骤 3. 发送 PING 检查通信状态。
- 步骤 4. 身份验证。
- 步骤 5. 发送端口信息。
- 步骤 6. 同步。
- 步骤 7. 命令传播。

## Redis 哨兵

【问题】

- Redis 如何实现高可用？
- Redis 哨兵的功能？
- Redis 哨兵的原理？
- Redis 哨兵如何选举 Leader？
- Redis 如何实现故障转移？

---

【解答】

（1）Redis 的高可用是通过哨兵来实现（Raft 协议的 Redis 实现）。Sentinel（哨兵）可以监听主服务器，并在主服务器进入下线状态时，自动从从服务器中选举出新的主服务器。

由一个或多个 Sentinel 实例组成的 Sentinel 系统可以监视任意多个主服务器，以及这些主服务器的所有从服务器，并在被监视的主服务器进入下线状态时，自动将下线主服务器的某个从服务器升级为新的主服务器，然后由新的主服务器代替已下线的主服务器继续处理命令请求。

![img](https://raw.githubusercontent.com/dunwu/images/dev/snap/20200131135847.png)

## Redis vs. Memcached

【问题】

Redis 和 Memcached 有什么区别？

分布式缓存技术选型，选 Redis 还是 Memcached，为什么？

Redis 和 Memcached 各自的线程模型是怎样的？

为什么单线程的 Redis 性能却不输于多线程的 Memcached？

【解答】

Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。memcache 支持简单的数据类型，String。

Redis 支持数据的备份，即 master-slave 模式的数据备份。

Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中

redis 的速度比 memcached 快很多

Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的 IO 复用模型。

![Redis与Memcached的区别与比较](https://user-gold-cdn.xitu.io/2018/4/18/162d7773080d4570?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如果想要更详细了解的话，可以查看慕课网上的这篇手记（非常推荐） **：《脚踏两只船的困惑 - Memcached 与 Redis》**：[www.imooc.com/article/23549](https://www.imooc.com/article/23549)

**终极策略：** 使用 Redis 的 String 类型做的事，都可以用 Memcached 替换，以此换取更好的性能提升； 除此以外，优先考虑 Redis；

## 参考资料

- [面试中关于 Redis 的问题看这篇就够了](https://juejin.im/post/5ad6e4066fb9a028d82c4b66)
- [advanced-java](https://github.com/doocs/advanced-java#缓存)